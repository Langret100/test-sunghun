<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ìˆ˜í•™ íƒí—˜ê°€</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #canvas {
            display: block;
            image-rendering: pixelated;
            cursor: crosshair;
            width: 100%;
            height: 100%;
        }
        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, rgba(0,0,0,0.98), rgba(10,20,30,0.95));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            z-index: 10;
            padding: 20px;
            overflow-y: auto;
        }
        .hidden { display: none !important; }
        .title {
            font-size: clamp(40px, 8vw, 60px);
            margin-bottom: 20px;
            text-shadow: 0 0 40px #0ff;
            animation: glow 2s infinite;
            text-align: center;
        }
        @keyframes glow {
            0%, 100% { text-shadow: 0 0 30px #0ff; }
            50% { text-shadow: 0 0 50px #0ff, 0 0 70px #0ff; }
        }
        .gameInfo {
            max-width: 600px;
            text-align: center;
            margin: 20px 0;
            line-height: 1.6;
            font-size: clamp(14px, 3vw, 18px);
        }
        .characterSelect {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin: 20px 0;
            max-width: 800px;
            width: 100%;
        }
        .character {
            border: 3px solid #0ff;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            background: linear-gradient(135deg, rgba(0,50,50,0.8), rgba(0,100,100,0.6));
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .character:hover, .character:active {
            transform: scale(1.05);
            box-shadow: 0 0 30px #0ff;
        }
        .character canvas {
            margin-bottom: 10px;
        }
        .button {
            padding: 15px 30px;
            font-size: clamp(18px, 4vw, 24px);
            background: linear-gradient(45deg, #0066cc, #00aaff);
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            margin: 10px;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,100,200,0.5);
        }
        .button:hover, .button:active {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0,150,255,0.7);
        }
        .upgradeCard {
            padding: 20px;
            border: 2px solid #ffd700;
            background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(255,165,0,0.2));
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            min-width: 150px;
            margin: 10px;
            font-size: clamp(14px, 3vw, 18px);
        }
        .upgradeCard:hover, .upgradeCard:active {
            transform: scale(1.05);
            box-shadow: 0 0 20px #ffd700;
        }
        #ui {
            position: absolute;
            top: 10px; left: 10px;
            color: white;
            font-size: clamp(14px, 3vw, 18px);
            text-shadow: 2px 2px 4px #000;
            z-index: 5;
            pointer-events: none;
        }
        .bar {
            width: 200px;
            height: 18px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #555;
            margin-top: 3px;
        }
        .fill {
            height: 100%;
            transition: width 0.3s;
        }
        .minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 120px;
            height: 120px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #0ff;
            z-index: 5;
        }
        .controls {
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-size: clamp(12px, 2.5vw, 16px);
        }
        .mathQuestion {
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #ffd700;
            max-width: 400px;
            animation: slideIn 0.3s;
        }
        @keyframes slideIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .mathQuestion h3 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: clamp(20px, 5vw, 28px);
        }
        .mathQuestion input {
            width: 100%;
            padding: 15px;
            font-size: clamp(18px, 4vw, 24px);
            text-align: center;
            border: 2px solid #0ff;
            background: rgba(0,50,50,0.5);
            color: white;
            border-radius: 8px;
            margin: 10px 0;
        }
        .mathButtons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .mathButtons button {
            flex: 1;
            padding: 12px;
            font-size: clamp(16px, 3vw, 20px);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .mathButtons .submit {
            background: linear-gradient(45deg, #0066cc, #00aaff);
            color: white;
        }
        .mathButtons .cancel {
            background: linear-gradient(45deg, #666, #888);
            color: white;
        }
        @media (max-width: 768px) {
            .bar { width: 150px; height: 15px; }
            .minimap { width: 80px; height: 80px; }
            #hardModeIndicator { top: 100px !important; font-size: 12px !important; }
        }
        .fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 140px;
            width: 36px;
            height: 36px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #0ff;
            border-radius: 5px;
            color: #0ff;
            font-size: 18px;
            cursor: pointer;
            z-index: 6;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .fullscreen-btn:hover {
            background: rgba(0,255,255,0.2);
            box-shadow: 0 0 10px #0ff;
        }
        .sound-btn {
            position: absolute;
            top: 10px;
            right: 185px;
            width: 36px;
            height: 36px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #0ff;
            border-radius: 5px;
            color: #0ff;
            font-size: 16px;
            cursor: pointer;
            z-index: 6;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .sound-btn:hover {
            background: rgba(0,255,255,0.2);
            box-shadow: 0 0 10px #0ff;
        }
        @media (max-width: 768px) {
            .fullscreen-btn {
                right: 100px;
                width: 32px;
                height: 32px;
                font-size: 16px;
            }
            .sound-btn {
                right: 140px;
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui" class="hidden">
        <div style="padding:8px;background:rgba(0,0,0,0.9);border-left:3px solid #0ff">
            <div>Lv.<span id="level">1</span> | <span id="score">0</span>ì </div>
            <div class="bar"><div class="fill" id="hp" style="width:100%;background:linear-gradient(90deg,#f44,#f88)"></div></div>
            <div class="bar"><div class="fill" id="exp" style="width:0;background:linear-gradient(90deg,#4f4,#8f8)"></div></div>
        </div>
        <div style="margin-top:5px;font-size:0.9em;background:rgba(0,0,0,0.7);padding:3px">
            ë¼ìš´ë“œ: <span id="stage">1</span> | <span id="time">0</span>ì´ˆ
        </div>
    </div>
    
    <canvas id="minimap" class="minimap hidden"></canvas>
    <span id="hardModeIndicator" class="hidden" style="position:absolute;top:140px;right:10px;color:#f44;font-weight:bold;font-size:14px;z-index:1000;text-shadow:0 0 5px #f00;">ğŸ”¥ í•˜ë“œëª¨ë“œ</span>
    <button id="fullscreenBtn" class="fullscreen-btn hidden" onclick="G.toggleFullscreen()">â›¶</button>
    <button id="soundBtn" class="sound-btn hidden" onclick="G.toggleSound()">ğŸ”Š</button>
    
    <div id="mainScreen" class="screen" onclick="SoundManager.startTitleMusic()">
        <h1 class="title" onclick="event.stopPropagation(); G.toggleHardMode();" style="cursor:pointer;">ğŸ§® ìˆ˜í•™ íƒí—˜ê°€ ğŸ§®</h1>
        <div class="gameInfo">
            <h3>ê²Œì„ ì„¤ëª…</h3>
            <p>ìˆ˜í•™ ë¬¸ì œë¥¼ í’€ë©° ëª¬ìŠ¤í„°ë“¤ê³¼ ì‹¸ìš°ëŠ” êµìœ¡ RPG!</p>
            <p>ë³´ë¬¼ìƒìë¥¼ ì—´ë ¤ë©´ ìˆ˜í•™ ë¬¸ì œë¥¼ ë§ì¶°ì•¼ í•©ë‹ˆë‹¤.</p>
            <p>ë³´ìŠ¤ ì²˜ì¹˜ ì‹œ ë‹¤ìŒ ë¼ìš´ë“œë¡œ ì§„í–‰ë©ë‹ˆë‹¤!</p>
        </div>
        <div class="controls">
            <b>ì¡°ì‘ë²•:</b><br>
            PC: ë§ˆìš°ìŠ¤ í´ë¦­ìœ¼ë¡œ ì´ë™<br>
            ëª¨ë°”ì¼: í„°ì¹˜ë¡œ ì´ë™
        </div>
        <p style="font-size:12px;color:#888;margin-top:10px">ğŸ”Š í™”ë©´ì„ í„°ì¹˜í•˜ë©´ ìŒì•…ì´ ì‹œì‘ë©ë‹ˆë‹¤</p>
        <button class="button" onclick="G.showCharSelect()">ê²Œì„ ì‹œì‘</button>
    </div>
    
    <div id="charScreen" class="screen hidden">
        <h2 class="title">ìºë¦­í„° ì„ íƒ</h2>
        <div class="characterSelect" id="charSelectGrid"></div>
    </div>
    
    <div id="levelUpScreen" class="screen hidden">
        <h2 class="title">ë ˆë²¨ ì—…!</h2>
        <p>ì—…ê·¸ë ˆì´ë“œ ì„ íƒ (í´ë¦­)</p>
        <div style="display:flex;flex-wrap:wrap;justify-content:center" id="upgrades"></div>
    </div>
    
    <div id="mathScreen" class="screen hidden">
        <div class="mathQuestion">
            <h3>ğŸ ë³´ë¬¼ìƒì ë¬¸ì œ!</h3>
            <p id="mathProblem" style="font-size:clamp(24px,5vw,32px);margin:20px 0;color:#0ff"></p>
            <input type="number" id="mathAnswer" placeholder="ë‹µì„ ì…ë ¥í•˜ì„¸ìš”">
            <div class="mathButtons">
                <button class="submit" onclick="G.checkMathAnswer()">í™•ì¸</button>
                <button class="cancel" onclick="G.closeMath()">ì·¨ì†Œ</button>
            </div>
        </div>
    </div>
    
    <div id="itemScreen" class="screen hidden">
        <h2 class="title">ğŸ ì•„ì´í…œ!</h2>
        <p>ì•„ì´í…œ ì„ íƒ (í´ë¦­)</p>
        <div style="display:flex;flex-wrap:wrap;justify-content:center" id="items"></div>
    </div>
    
    <div id="gameOverScreen" class="screen hidden">
        <h1 class="title">ê²Œì„ ì˜¤ë²„</h1>
        <div id="finalStats" style="font-size:clamp(20px,4vw,28px);margin:20px"></div>
        <button class="button" onclick="location.reload()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>

<script>
// ===== ì‚¬ìš´ë“œ ë§¤ë‹ˆì € (Web Audio API) =====
const SoundManager = {
    ctx: null,
    enabled: true,
    musicEnabled: true,
    volume: 0.3,
    musicVolume: 0.15,
    musicOsc: null,
    musicGain: null,
    
    init() {
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
            console.log('Web Audio API not supported');
            this.enabled = false;
        }
    },
    
    resume() {
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    
    // ê¸°ë³¸ íš¨ê³¼ìŒ ìƒì„±
    play(type, freq = 440, duration = 0.1) {
        if (!this.enabled || !this.ctx) return;
        this.resume();
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(this.volume, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    
    // ê³µê²© íš¨ê³¼ìŒ
    attack(charType) {
        if (!this.enabled || !this.ctx) return;
        this.resume();
        
        if (charType === 'warrior' || charType === 'valkyrie') {
            // ë² ê¸°/íƒ€ê²©ìŒ - ë…¸ì´ì¦ˆ + ì €ìŒ
            this.playNoise(0.08, 800, 200);
            this.play('sawtooth', 150, 0.1);
        } else if (charType === 'mage') {
            // ë§ˆë²• ë°œì‚¬ìŒ - ê³ ìŒ ìŠ¤ìœ•
            this.playSweep('sine', 800, 1200, 0.15);
        } else if (charType === 'archer') {
            // í™”ì‚´ ë°œì‚¬ìŒ - ì§§ì€ ìŠ¤ìœ•
            this.playSweep('triangle', 400, 200, 0.08);
        }
    },
    
    // ìŠ¤ìœ• ì‚¬ìš´ë“œ (ì£¼íŒŒìˆ˜ ë³€í™”)
    playSweep(type, startFreq, endFreq, duration) {
        if (!this.enabled || !this.ctx) return;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.type = type;
        osc.frequency.setValueAtTime(startFreq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(endFreq, this.ctx.currentTime + duration);
        gain.gain.setValueAtTime(this.volume * 0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    
    // ë…¸ì´ì¦ˆ ìƒì„± (íƒ€ê²©ìŒìš©)
    playNoise(duration, highFreq = 1000, lowFreq = 100) {
        if (!this.enabled || !this.ctx) return;
        
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        
        const noise = this.ctx.createBufferSource();
        const filter = this.ctx.createBiquadFilter();
        const gain = this.ctx.createGain();
        
        noise.buffer = buffer;
        filter.type = 'bandpass';
        filter.frequency.value = (highFreq + lowFreq) / 2;
        filter.Q.value = 1;
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        
        gain.gain.setValueAtTime(this.volume * 0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        noise.start();
        noise.stop(this.ctx.currentTime + duration);
    },
    
    // ì  í”¼ê²©
    hit() {
        this.play('square', 200, 0.05);
    },
    
    // ì  ì²˜ì¹˜
    kill() {
        this.playSweep('square', 400, 100, 0.15);
        setTimeout(() => this.play('sine', 600, 0.1), 50);
    },
    
    // í”Œë ˆì´ì–´ í”¼ê²©
    playerHit() {
        this.play('sawtooth', 100, 0.15);
        this.playNoise(0.1, 300, 100);
    },
    
    // ë ˆë²¨ì—…
    levelUp() {
        if (!this.enabled || !this.ctx) return;
        this.resume();
        
        const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
        notes.forEach((freq, i) => {
            setTimeout(() => this.play('sine', freq, 0.2), i * 100);
        });
    },
    
    // ë³´ìŠ¤ ë“±ì¥
    bossAppear() {
        if (!this.enabled || !this.ctx) return;
        this.resume();
        
        // ê²½ê³ ìŒ
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                this.play('sawtooth', 150, 0.2);
                this.play('square', 75, 0.2);
            }, i * 300);
        }
    },
    
    // ë³´ìŠ¤ ì²˜ì¹˜
    bossKill() {
        if (!this.enabled || !this.ctx) return;
        this.resume();
        
        const notes = [262, 330, 392, 523, 659, 784, 1047];
        notes.forEach((freq, i) => {
            setTimeout(() => this.play('sine', freq, 0.25), i * 80);
        });
    },
    
    // ì•„ì´í…œ íšë“
    item() {
        this.playSweep('sine', 500, 1000, 0.1);
    },
    
    // ë³´ë¬¼ìƒì ì˜¤í”ˆ
    chest() {
        this.play('triangle', 800, 0.1);
        setTimeout(() => this.play('triangle', 1000, 0.1), 100);
        setTimeout(() => this.play('triangle', 1200, 0.15), 200);
    },
    
    // ì •ë‹µ
    correct() {
        this.play('sine', 880, 0.1);
        setTimeout(() => this.play('sine', 1100, 0.15), 100);
    },
    
    // ì˜¤ë‹µ
    wrong() {
        this.play('sawtooth', 200, 0.2);
        setTimeout(() => this.play('sawtooth', 150, 0.25), 150);
    },
    
    // ë°°ê²½ìŒì•… ì‹œì‘
    startMusic() {
        if (!this.enabled || !this.ctx || !this.musicEnabled) return;
        this.resume();
        
        // ì´ë¯¸ ì¬ìƒ ì¤‘ì´ë©´ ì¤‘ì§€
        this.stopMusic();
        
        // ê°„ë‹¨í•œ ì•„ë¥´í˜ì§€ì˜¤ ë°°ê²½ìŒì•…
        this.musicPlaying = true;
        if (hardMode) {
            this.hardMusicLoop();
        } else {
            this.musicLoop();
        }
    },
    
    musicLoop() {
        if (!this.musicPlaying || !this.musicEnabled) return;
        
        // 8ë¹„íŠ¸ ìŠ¤íƒ€ì¼ ë°°ê²½ìŒì•… íŒ¨í„´
        const patterns = [
            [130.81, 164.81, 196.00, 261.63], // C3, E3, G3, C4
            [146.83, 185.00, 220.00, 293.66], // D3, F#3, A3, D4
            [164.81, 207.65, 246.94, 329.63], // E3, G#3, B3, E4
            [130.81, 164.81, 196.00, 261.63], // C3, E3, G3, C4
        ];
        
        let noteIndex = 0;
        let patternIndex = 0;
        
        const playNote = () => {
            if (!this.musicPlaying || !this.musicEnabled) return;
            
            const pattern = patterns[patternIndex];
            const freq = pattern[noteIndex];
            
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            osc.type = 'triangle';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(this.musicVolume, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
            
            osc.start();
            osc.stop(this.ctx.currentTime + 0.35);
            
            noteIndex++;
            if (noteIndex >= pattern.length) {
                noteIndex = 0;
                patternIndex = (patternIndex + 1) % patterns.length;
            }
            
            this.musicTimeout = setTimeout(playNote, 250);
        };
        
        playNote();
    },
    
    // í•˜ë“œëª¨ë“œ ë°°ê²½ìŒì•… (ë” ê²©í•˜ê³  ë¹ ë¦„)
    hardMusicLoop() {
        if (!this.musicPlaying || !this.musicEnabled) return;
        
        // ê²©ë ¬í•œ ìŒì•… íŒ¨í„´ (ë‹¨ì¡°, ë” ë†’ì€ ìŒ)
        const patterns = [
            [196.00, 246.94, 293.66, 392.00], // G3, B3, D4, G4
            [220.00, 277.18, 329.63, 440.00], // A3, C#4, E4, A4
            [185.00, 233.08, 277.18, 369.99], // F#3, Bb3, C#4, F#4
            [196.00, 246.94, 311.13, 392.00], // G3, B3, Eb4, G4
        ];
        
        // ë“œëŸ¼ ë¹„íŠ¸ íŒ¨í„´
        const drumPattern = [1, 0, 1, 1, 0, 1, 1, 0];
        
        let noteIndex = 0;
        let patternIndex = 0;
        let beatCount = 0;
        
        const playNote = () => {
            if (!this.musicPlaying || !this.musicEnabled) return;
            
            const pattern = patterns[patternIndex];
            const freq = pattern[noteIndex];
            
            // ë©”ì¸ ë©œë¡œë”” (square - ë” ê°•ë ¬í•œ ì†Œë¦¬)
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            osc.type = 'square';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(this.musicVolume * 0.7, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
            
            osc.start();
            osc.stop(this.ctx.currentTime + 0.18);
            
            // ë“œëŸ¼ ë¹„íŠ¸
            if (drumPattern[beatCount % 8]) {
                const drumOsc = this.ctx.createOscillator();
                const drumGain = this.ctx.createGain();
                
                drumOsc.connect(drumGain);
                drumGain.connect(this.ctx.destination);
                
                drumOsc.type = 'sine';
                drumOsc.frequency.setValueAtTime(80, this.ctx.currentTime);
                drumOsc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.08);
                drumGain.gain.setValueAtTime(this.musicVolume * 1.0, this.ctx.currentTime);
                drumGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
                
                drumOsc.start();
                drumOsc.stop(this.ctx.currentTime + 0.1);
            }
            
            noteIndex++;
            beatCount++;
            if (noteIndex >= pattern.length) {
                noteIndex = 0;
                patternIndex = (patternIndex + 1) % patterns.length;
            }
            
            this.musicTimeout = setTimeout(playNote, 160); // ë” ë¹ ë¥¸ í…œí¬
        };
        
        playNote();
    },
    
    stopMusic() {
        this.musicPlaying = false;
        this.titleMusicPlaying = false;
        this.bossMusicPlaying = false;
        if (this.musicTimeout) {
            clearTimeout(this.musicTimeout);
            this.musicTimeout = null;
        }
    },
    
    // ë³´ìŠ¤ ì „íˆ¬ ìŒì•…
    startBossMusic() {
        if (!this.enabled || !this.ctx || !this.musicEnabled) return;
        this.resume();
        
        this.stopMusic();
        this.bossMusicPlaying = true;
        if (hardMode) {
            this.hardBossMusicLoop();
        } else {
            this.bossMusicLoop();
        }
    },
    
    bossMusicLoop() {
        if (!this.bossMusicPlaying || !this.musicEnabled) return;
        
        // ê¸´ë°•í•œ ë³´ìŠ¤ ì „íˆ¬ ìŒì•… íŒ¨í„´ (ë‹¨ì¡°, ë¹ ë¥¸ í…œí¬)
        const patterns = [
            [110.00, 130.81, 164.81, 130.81], // A2, C3, E3, C3 (Am)
            [116.54, 146.83, 174.61, 146.83], // Bb2, D3, F3, D3 (Bb)
            [103.83, 130.81, 155.56, 130.81], // G#2, C3, Eb3, C3 (dim)
            [110.00, 138.59, 164.81, 138.59], // A2, C#3, E3, C#3 (A)
        ];
        
        // ë² ì´ìŠ¤ ë“œëŸ¼ íŒ¨í„´
        const bassPattern = [1, 0, 1, 0, 1, 0, 1, 1];
        
        let noteIndex = 0;
        let patternIndex = 0;
        let beatCount = 0;
        
        const playNote = () => {
            if (!this.bossMusicPlaying || !this.musicEnabled) return;
            
            const pattern = patterns[patternIndex];
            const freq = pattern[noteIndex];
            
            // ë©”ì¸ ë©œë¡œë”” (sawtooth - ë” ë‚ ì¹´ë¡œìš´ ì†Œë¦¬)
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            osc.type = 'sawtooth';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(this.musicVolume * 0.8, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.12);
            
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
            
            // ë² ì´ìŠ¤ ë“œëŸ¼ (ë‚®ì€ ì£¼íŒŒìˆ˜ í„ìŠ¤)
            if (bassPattern[beatCount % 8]) {
                const bassOsc = this.ctx.createOscillator();
                const bassGain = this.ctx.createGain();
                
                bassOsc.connect(bassGain);
                bassGain.connect(this.ctx.destination);
                
                bassOsc.type = 'sine';
                bassOsc.frequency.setValueAtTime(60, this.ctx.currentTime);
                bassOsc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.1);
                bassGain.gain.setValueAtTime(this.musicVolume * 1.2, this.ctx.currentTime);
                bassGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                
                bassOsc.start();
                bassOsc.stop(this.ctx.currentTime + 0.12);
            }
            
            noteIndex++;
            beatCount++;
            if (noteIndex >= pattern.length) {
                noteIndex = 0;
                patternIndex = (patternIndex + 1) % patterns.length;
            }
            
            this.musicTimeout = setTimeout(playNote, 140); // ë¹ ë¥¸ í…œí¬
        };
        
        playNote();
    },
    
    // í•˜ë“œëª¨ë“œ ë³´ìŠ¤ ìŒì•… (ê·¹ë„ë¡œ ê²©ë ¬í•¨)
    hardBossMusicLoop() {
        if (!this.bossMusicPlaying || !this.musicEnabled) return;
        
        // ê·¹ë„ë¡œ ê¸´ë°•í•œ íŒ¨í„´ (ë¶ˆí˜‘í™”ìŒ í¬í•¨)
        const patterns = [
            [130.81, 155.56, 196.00, 233.08], // C3, Eb3, G3, Bb3
            [146.83, 174.61, 220.00, 261.63], // D3, F3, A3, C4
            [123.47, 155.56, 185.00, 220.00], // B2, Eb3, F#3, A3
            [138.59, 164.81, 207.65, 246.94], // C#3, E3, G#3, B3
        ];
        
        // ë¹ ë¥¸ ë“œëŸ¼ íŒ¨í„´
        const drumPattern = [1, 1, 0, 1, 1, 0, 1, 1];
        const hihatPattern = [1, 1, 1, 1, 1, 1, 1, 1];
        
        let noteIndex = 0;
        let patternIndex = 0;
        let beatCount = 0;
        
        const playNote = () => {
            if (!this.bossMusicPlaying || !this.musicEnabled) return;
            
            const pattern = patterns[patternIndex];
            const freq = pattern[noteIndex];
            
            // ë©”ì¸ ë©œë¡œë”” (sawtooth + ì˜¥íƒ€ë¸Œ ìœ„)
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            osc.type = 'sawtooth';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(this.musicVolume * 0.9, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
            
            osc.start();
            osc.stop(this.ctx.currentTime + 0.1);
            
            // ì˜¥íƒ€ë¸Œ ìœ„ ì¶”ê°€
            const osc2 = this.ctx.createOscillator();
            const gain2 = this.ctx.createGain();
            
            osc2.connect(gain2);
            gain2.connect(this.ctx.destination);
            
            osc2.type = 'square';
            osc2.frequency.value = freq * 2;
            gain2.gain.setValueAtTime(this.musicVolume * 0.4, this.ctx.currentTime);
            gain2.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.06);
            
            osc2.start();
            osc2.stop(this.ctx.currentTime + 0.08);
            
            // ë² ì´ìŠ¤ ë“œëŸ¼
            if (drumPattern[beatCount % 8]) {
                const bassOsc = this.ctx.createOscillator();
                const bassGain = this.ctx.createGain();
                
                bassOsc.connect(bassGain);
                bassGain.connect(this.ctx.destination);
                
                bassOsc.type = 'sine';
                bassOsc.frequency.setValueAtTime(80, this.ctx.currentTime);
                bassOsc.frequency.exponentialRampToValueAtTime(35, this.ctx.currentTime + 0.06);
                bassGain.gain.setValueAtTime(this.musicVolume * 1.4, this.ctx.currentTime);
                bassGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.06);
                
                bassOsc.start();
                bassOsc.stop(this.ctx.currentTime + 0.08);
            }
            
            // í•˜ì´í–‡
            if (hihatPattern[beatCount % 8]) {
                const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.03, this.ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseBuffer.length; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                const noiseGain = this.ctx.createGain();
                noise.buffer = noiseBuffer;
                noise.connect(noiseGain);
                noiseGain.connect(this.ctx.destination);
                noiseGain.gain.setValueAtTime(this.musicVolume * 0.3, this.ctx.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.02);
                noise.start();
            }
            
            noteIndex++;
            beatCount++;
            if (noteIndex >= pattern.length) {
                noteIndex = 0;
                patternIndex = (patternIndex + 1) % patterns.length;
            }
            
            this.musicTimeout = setTimeout(playNote, 100); // ê·¹ë„ë¡œ ë¹ ë¥¸ í…œí¬
        };
        
        playNote();
    },
    
    // íƒ€ì´í‹€ í™”ë©´ ìŒì•…
    startTitleMusic() {
        if (!this.enabled || !this.ctx || !this.musicEnabled) return;
        this.resume();
        
        this.stopMusic();
        this.titleMusicPlaying = true;
        this.titleMusicLoop();
    },
    
    titleMusicLoop() {
        if (!this.titleMusicPlaying || !this.musicEnabled) return;
        
        // ë¶€ë“œëŸ½ê³  ì‹ ë¹„ë¡œìš´ íƒ€ì´í‹€ ìŒì•… íŒ¨í„´
        const patterns = [
            [261.63, 329.63, 392.00, 329.63], // C4, E4, G4, E4
            [293.66, 369.99, 440.00, 369.99], // D4, F#4, A4, F#4
            [329.63, 415.30, 493.88, 415.30], // E4, G#4, B4, G#4
            [261.63, 329.63, 392.00, 523.25], // C4, E4, G4, C5
        ];
        
        let noteIndex = 0;
        let patternIndex = 0;
        
        const playNote = () => {
            if (!this.titleMusicPlaying || !this.musicEnabled) return;
            
            const pattern = patterns[patternIndex];
            const freq = pattern[noteIndex];
            
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            osc.type = 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(this.musicVolume * 0.7, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
            
            osc.start();
            osc.stop(this.ctx.currentTime + 0.55);
            
            noteIndex++;
            if (noteIndex >= pattern.length) {
                noteIndex = 0;
                patternIndex = (patternIndex + 1) % patterns.length;
            }
            
            this.musicTimeout = setTimeout(playNote, 400);
        };
        
        playNote();
    },
    
    // í† ê¸€
    toggle() {
        this.enabled = !this.enabled;
        if (!this.enabled) this.stopMusic();
        return this.enabled;
    },
    
    toggleMusic() {
        this.musicEnabled = !this.musicEnabled;
        if (this.musicEnabled) {
            this.startMusic();
        } else {
            this.stopMusic();
        }
        return this.musicEnabled;
    }
};

// ì‚¬ìš´ë“œ ë§¤ë‹ˆì € ì´ˆê¸°í™”
SoundManager.init();

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false }); // alpha ë¹„í™œì„±í™”ë¡œ ì„±ëŠ¥ í–¥ìƒ
const minimapCanvas = document.getElementById('minimap');
const minimapCtx = minimapCanvas.getContext('2d');

// ===== ê²Œì„ ì†ë„ ê´€ë ¨ ë³€ìˆ˜ =====
let lastFrameTime = 0;
const TARGET_FPS = 60;
const FRAME_TIME = 1000 / TARGET_FPS;  // 16.67ms
let gameSpeedMultiplier = 1;
let hardMode = false;  // í•˜ë“œëª¨ë“œ í”Œë˜ê·¸

// ===== ëª¨ë°”ì¼ ê°ì§€ =====
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                 || window.innerWidth < 768;

// ===== í™”ë©´ ìŠ¤ì¼€ì¼ (ëª¨ë°”ì¼ì—ì„œ ë” ë„“ê²Œ ë³´ê¸°) =====
let viewScale = 1;

// ===== ìºì‹œëœ ê³„ì‚° ë³€ìˆ˜ (ì„±ëŠ¥ ìµœì í™”) =====
let cachedCanvasWidth = 0;
let cachedCanvasHeight = 0;
let cachedCameraX = 0;
let cachedCameraY = 0;

function resizeCanvas() {
    // ì‹¤ì œ í•´ìƒë„ ì„¤ì •
    const baseWidth = window.innerWidth;
    const baseHeight = window.innerHeight;
    
    // ëª¨ë°”ì¼ì—ì„œëŠ” ë” ë„“ì€ ì˜ì—­ì„ ë³´ì—¬ì£¼ê¸° ìœ„í•´ ìŠ¤ì¼€ì¼ ì¡°ì •
    if (isMobile) {
        // ëª¨ë°”ì¼: ê°€ìƒ í•´ìƒë„ë¥¼ í¬ê²Œ ì„¤ì • (ë” ë„“ê²Œ ë³´ì„)
        viewScale = Math.max(baseWidth, baseHeight) < 600 ? 1.5 : 1.3;
        canvas.width = Math.floor(baseWidth * viewScale);
        canvas.height = Math.floor(baseHeight * viewScale);
    } else {
        viewScale = 1;
        canvas.width = baseWidth;
        canvas.height = baseHeight;
    }
    
    // ìºì‹œ ì—…ë°ì´íŠ¸
    cachedCanvasWidth = canvas.width;
    cachedCanvasHeight = canvas.height;
    
    ctx.imageSmoothingEnabled = false;
    
    const minimapSize = isMobile ? 80 : 120;
    minimapCanvas.width = minimapSize;
    minimapCanvas.height = minimapSize;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// ===== ìºë¦­í„° ë””ìì¸ ì •ì˜ =====
// ê° ìºë¦­í„°ì˜ í”½ì…€ ì•„íŠ¸ ê·¸ë˜í”½ê³¼ ì„¤ëª…
const CHAR_DESIGNS = [
    {
        name: "ì „ì‚¬",
        type: "warrior",
        desc: "ë†’ì€ ì²´ë ¥ì˜ ê·¼ì ‘ ì „íˆ¬",  // ì²´ë ¥ 1.5ë°°, ê·¼ì ‘ ë² ê¸° ê³µê²©
        draw: function(ctx, frame = 0, scale = 1) {
            const p = 2 * scale;
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-3*p, -10*p, 6*p, 5*p);
            ctx.fillStyle = '#fff';
            ctx.fillRect(-2*p, -8*p, 1*p, 2*p);
            ctx.fillRect(1*p, -8*p, 1*p, 2*p);
            ctx.fillStyle = '#000';
            ctx.fillRect(-2*p, -8*p, 1*p, 1*p);
            ctx.fillRect(1*p, -8*p, 1*p, 1*p);
            ctx.fillStyle = '#654321';
            ctx.fillRect(-3*p, -11*p, 6*p, 2*p);
            ctx.fillStyle = '#8b0000';
            ctx.fillRect(-4*p, -5*p, 8*p, 6*p);
            ctx.fillStyle = '#666';
            ctx.fillRect(-5*p, -5*p, 2*p, 3*p);
            ctx.fillRect(3*p, -5*p, 2*p, 3*p);
            ctx.fillStyle = '#fdbcb4';
            const armFrame = frame % 2 === 0 ? 0 : 1;
            ctx.fillRect(-5*p, -2*p + armFrame*p, 1*p, 4*p);
            ctx.fillRect(4*p, -2*p - armFrame*p, 1*p, 4*p);
            ctx.fillStyle = '#333';
            ctx.fillRect(-3*p, 1*p, 2*p, 6*p - frame*p);
            ctx.fillRect(1*p, 1*p, 2*p, 6*p + frame*p);
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(5*p, -3*p, 1*p, 6*p);
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(5*p, 3*p, 1*p, 1*p);
        }
    },
    {
        name: "ê¶ìˆ˜",
        type: "ranger",
        desc: "ë¹ ë¥¸ ì›ê±°ë¦¬ ê³µê²©",  // ì›ê±°ë¦¬ í™”ì‚´ ê³µê²©, ê´€í†µë ¥
        draw: function(ctx, frame = 0, scale = 1) {
            const p = 2 * scale;
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-3*p, -10*p, 6*p, 5*p);
            ctx.fillStyle = '#000';
            ctx.fillRect(-2*p, -8*p, 1*p, 1*p);
            ctx.fillRect(1*p, -8*p, 1*p, 1*p);
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(-4*p, -11*p, 8*p, 2*p);
            ctx.fillRect(-3*p, -9*p, 6*p, 1*p);
            ctx.fillStyle = '#654321';
            ctx.fillRect(-3*p, -5*p, 6*p, 6*p);
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(-4*p, -4*p, 1*p, 5*p);
            ctx.fillRect(3*p, -4*p, 1*p, 5*p);
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-4*p, -2*p, 1*p, 4*p);
            ctx.fillRect(3*p, -2*p, 1*p, 4*p);
            ctx.fillStyle = '#654321';
            ctx.fillRect(-3*p, 1*p, 2*p, 6*p - frame*p);
            ctx.fillRect(1*p, 1*p, 2*p, 6*p + frame*p);
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(4*p, -6*p, 1*p, 8*p);
        }
    },
    {
        name: "ë§ˆë²•ì‚¬",
        type: "mage",
        desc: "ê°•ë ¥í•œ ë§ˆë²• ê³µê²©",  // ì›ê±°ë¦¬ ë§ˆë²•íƒ„ ê³µê²©, ë¹ ë¥¸ ê³µê²©ì†ë„
        draw: function(ctx, frame = 0, scale = 1) {
            const p = 2 * scale;
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-3*p, -9*p, 6*p, 5*p);
            ctx.fillStyle = '#00f';
            ctx.fillRect(-2*p, -7*p, 1*p, 1*p);
            ctx.fillRect(1*p, -7*p, 1*p, 1*p);
            ctx.fillStyle = '#4b0082';
            ctx.fillRect(-3*p, -10*p, 6*p, 1*p);
            ctx.fillRect(-2*p, -13*p, 4*p, 3*p);
            ctx.fillRect(-1*p, -15*p, 2*p, 2*p);
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(0, -11*p, 1*p, 1*p);
            ctx.fillStyle = '#4b0082';
            ctx.fillRect(-4*p, -4*p, 8*p, 7*p);
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-4*p, 0, 8*p, 1*p);
            ctx.fillStyle = '#4b0082';
            ctx.fillRect(-5*p, -2*p, 2*p, 5*p);
            ctx.fillRect(3*p, -2*p, 2*p, 5*p);
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-6*p, -8*p, 1*p, 10*p);
            ctx.fillStyle = '#0ff';
            ctx.fillRect(-7*p, -9*p, 3*p, 2*p);
        }
    },
    {
        name: "ë°œí‚¤ë¦¬",
        type: "valkyrie",
        desc: "ê°•ë ¥í•œ ë§ì¹˜ ê·¼ì ‘ ê³µê²©",  // ê·¼ì ‘ ë§ì¹˜ ê³µê²©, ë†’ì€ ë°ë¯¸ì§€, ëŠë¦° ê³µê²©ì†ë„
        draw: function(ctx, frame = 0, scale = 1) {
            const p = 2 * scale;
            
            // ê¸´ ë¨¸ë¦¬ì¹´ë½ (ê¸ˆë°œ, ë’¤ì— ë°°ì¹˜)
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-3*p, -8*p, 1.5*p, 10*p);  // ì™¼ìª½ ë¨¸ë¦¬ì¹´ë½
            ctx.fillRect(1.5*p, -8*p, 1.5*p, 10*p);   // ì˜¤ë¥¸ìª½ ë¨¸ë¦¬ì¹´ë½
            ctx.fillStyle = '#e6c200';
            ctx.fillRect(-2.5*p, -6*p, 0.8*p, 8*p);  // ë¨¸ë¦¬ì¹´ë½ ê·¸ë¦¼ì
            ctx.fillRect(1.7*p, -6*p, 0.8*p, 8*p);
            
            // ì–¼êµ´ (ì‘ê²Œ)
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-2*p, -9*p, 4*p, 4*p);
            
            // ëˆˆ (ì ìœ¼ë¡œ ë‹¨ìˆœí•˜ê²Œ)
            ctx.fillStyle = '#000';
            ctx.fillRect(-1*p, -7.5*p, 0.6*p, 0.6*p);
            ctx.fillRect(0.4*p, -7.5*p, 0.6*p, 0.6*p);
            
            // ì…ìˆ  (í•‘í¬ìƒ‰)
            ctx.fillStyle = '#ff9999';
            ctx.fillRect(-0.6*p, -5.8*p, 1.2*p, 0.4*p);
            
            // ë³¼ í„°ì¹˜ (ë¸”ëŸ¬ì…”)
            ctx.fillStyle = 'rgba(255, 150, 150, 0.5)';
            ctx.fillRect(-1.8*p, -6.5*p, 0.8*p, 0.6*p);
            ctx.fillRect(1*p, -6.5*p, 0.8*p, 0.6*p);
            
            // í‹°ì•„ë¼ (ì€ìƒ‰ + ë³´ì„)
            ctx.fillStyle = '#e8e8e8';
            ctx.fillRect(-2.5*p, -10*p, 5*p, 1.2*p);
            ctx.fillStyle = '#c0c0c0';
            ctx.beginPath();
            ctx.moveTo(-1.5*p, -10*p);
            ctx.lineTo(-0.8*p, -11.5*p);
            ctx.lineTo(0, -10*p);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(0, -10*p);
            ctx.lineTo(0.8*p, -11.5*p);
            ctx.lineTo(1.5*p, -10*p);
            ctx.closePath();
            ctx.fill();
            // ë³´ì„
            ctx.fillStyle = '#ff69b4';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#ff69b4';
            ctx.fillRect(-0.4*p, -11*p, 0.8*p, 0.8*p);
            ctx.shadowBlur = 0;
            
            // ì•ë¨¸ë¦¬
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-2*p, -9*p, 4*p, 1.2*p);
            ctx.fillRect(-2.5*p, -8.5*p, 0.8*p, 0.8*p);
            ctx.fillRect(1.7*p, -8.5*p, 0.8*p, 0.8*p);
            
            // ê°‘ì˜· ìƒì˜ (ì€ìƒ‰ + í•‘í¬ ì¥ì‹)
            ctx.fillStyle = '#d4d4d4';
            ctx.fillRect(-2.5*p, -5*p, 5*p, 3*p);
            ctx.fillStyle = '#ff69b4';
            ctx.fillRect(-2.5*p, -5*p, 5*p, 0.4*p);
            
            // í—ˆë¦¬ (ì–‡ê²Œ)
            ctx.fillStyle = '#d4d4d4';
            ctx.fillRect(-1.5*p, -2*p, 3*p, 2*p);
            ctx.fillStyle = '#ff69b4';
            ctx.fillRect(-1.5*p, -1*p, 3*p, 0.5*p);  // ë²¨íŠ¸
            
            // ì–´ê¹¨ ë³´í˜¸ëŒ€ (ë‘¥ê·¼ í˜•íƒœ)
            ctx.fillStyle = '#c0c0c0';
            ctx.beginPath();
            ctx.arc(-3*p, -4*p, 1.2*p, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(3*p, -4*p, 1.2*p, 0, Math.PI * 2);
            ctx.fill();
            
            // íŒ” (ê°€ëŠë‹¤ë€)
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-4*p, -3*p, 1*p, 3*p);
            ctx.fillRect(3*p, -3*p, 1*p, 3*p);
            
            // ì¥ê°‘
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(-4*p, 0, 1*p, 1.5*p);
            ctx.fillRect(3*p, 0, 1*p, 1.5*p);
            
            // ì§§ì€ ì¹˜ë§ˆ (ë¯¸ë‹ˆìŠ¤ì»¤íŠ¸)
            ctx.fillStyle = '#ff69b4';
            ctx.beginPath();
            ctx.moveTo(-1.5*p, 0);
            ctx.lineTo(-3*p, 3*p);
            ctx.lineTo(3*p, 3*p);
            ctx.lineTo(1.5*p, 0);
            ctx.closePath();
            ctx.fill();
            // ì¹˜ë§ˆ ì¥ì‹
            ctx.fillStyle = '#d4d4d4';
            ctx.fillRect(-2.5*p, 2.5*p, 5*p, 0.5*p);
            
            // ë‹¤ë¦¬ (ê°€ëŠë‹¤ë€)
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-1.8*p, 3*p, 1.2*p, 3*p - frame*p*0.5);
            ctx.fillRect(0.6*p, 3*p, 1.2*p, 3*p + frame*p*0.5);
            
            // ë¶€ì¸  (ì€ìƒ‰, ìš°ì•„í•œ)
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(-2*p, 5.5*p - frame*p*0.5, 1.6*p, 2*p);
            ctx.fillRect(0.4*p, 5.5*p + frame*p*0.5, 1.6*p, 2*p);
            ctx.fillStyle = '#ff69b4';  // ë¶€ì¸  ë¦¬ë³¸
            ctx.fillRect(-1.6*p, 5.8*p - frame*p*0.5, 0.8*p, 0.4*p);
            ctx.fillRect(0.8*p, 5.8*p + frame*p*0.5, 0.8*p, 0.4*p);
            
            // ì „ìŸ ë§ì¹˜ (ë” í™”ë ¤í•˜ê²Œ)
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(4*p, -6*p, 1*p, 9*p);
            // ë§ì¹˜ ë¨¸ë¦¬ (ê¸ˆìƒ‰ + ì€ìƒ‰)
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(3*p, -8*p, 3*p, 2.5*p);
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(3.3*p, -7.5*p, 2.4*p, 1.5*p);
            // ë§ì¹˜ ì¥ì‹
            ctx.fillStyle = '#ff69b4';
            ctx.fillRect(4.2*p, -7.8*p, 0.6*p, 0.6*p);
        }
    }
];

const MAP_WIDTH = 3000;
const MAP_HEIGHT = 3000;
const MAX_ENEMIES = 60;

const G = {
    player: null,
    enemies: [],
    projectiles: [],
    particles: [],
    obstacles: [],
    items: [],
    effects: [],
    slashes: [],
    pets: [],  // í« ë°°ì—´ ì¶”ê°€
    petProjectiles: [],  // í« íˆ¬ì‚¬ì²´ ë°°ì—´ ì¶”ê°€
    camera: {x: 0, y: 0},
    mouse: {x: 0, y: 0, pressed: false},
    touch: {x: 0, y: 0, active: false},
    running: false,
    paused: false,
    stage: 1,
    score: 0,
    lastSpawn: 0,
    startTime: 0,
    screenShake: 0,
    currentChest: null,
    currentProblem: null,
    boss: null,
    lastBossScore: 0,
    bossCount: 0,  // ë³´ìŠ¤ ì¶œí˜„ íšŸìˆ˜ ì¹´ìš´í„°
    rangedEffectQueue: [],  // ì›ê±°ë¦¬ íš¨ê³¼ í
    lastRangedEffectTime: 0,  // ë§ˆì§€ë§‰ ì›ê±°ë¦¬ íš¨ê³¼ ë°œë™ ì‹œê°„
    
    // ===== ë ˆë²¨ì—… ì‹œ ì„ íƒ ê°€ëŠ¥í•œ ì—…ê·¸ë ˆì´ë“œ =====
    UPGRADES: [
        {name: "ì²´ë ¥ ì¦ê°€", icon: "â¤ï¸", apply: p => { 
            p.maxHp += 50;         // ìµœëŒ€ ì²´ë ¥ +50
            p.hp = Math.min(p.hp + 50, p.maxHp);  // í˜„ì¬ ì²´ë ¥ë„ +50
        }},
        {name: "ê³µê²©ë ¥ ì¦ê°€", icon: "âš”ï¸", apply: p => { 
            p.damage += 10;        // ê³µê²©ë ¥ +10
        }},
        {name: "ê³µê²©ì†ë„ ì¦ê°€", icon: "â±ï¸", apply: p => { 
            p.atkSpeed = Math.max(100, p.atkSpeed - 50);  // ê³µê²© ì†ë„ +50ms (ìµœì†Œ 100ms)
        }},
        {name: "ì´ë™ì†ë„ ì¦ê°€", icon: "ğŸ‘Ÿ", apply: p => { 
            p.speed += 0.5;        // ì´ë™ì†ë„ +0.5
        }},
        {name: "ê´€í†µ", icon: "ğŸ¯", apply: p => { 
            p.pierce++;            // íˆ¬ì‚¬ì²´ ê´€í†µ +1
        }},
        {name: "ì²´ë ¥ íšŒë³µ", icon: "ğŸ’Š", apply: p => { 
            if (!p.regen) p.regen = 0;
            p.regen += 0.5;        // ì´ˆë‹¹ ì²´ë ¥ íšŒë³µ +0.5
        }},
        {name: "ë³´í˜¸ë§‰", icon: "ğŸ›¡ï¸", apply: p => { 
            p.shield = true;       // ë³´í˜¸ë§‰ í™œì„±í™”
            p.shieldHp = 100;      // ë³´í˜¸ë§‰ ì²´ë ¥ 100
        }}
    ],
    
    // ===== ì•„ì´í…œ ì •ì˜ (ë³´ë¬¼ìƒìì—ì„œ íšë“ ê°€ëŠ¥) =====
    // ëª¨ë“  ì•„ì´í…œì€ ë ˆë²¨ì—… ê°€ëŠ¥í•˜ë©°, ì  íƒ€ê²©ì‹œ ë°œë™ë©ë‹ˆë‹¤.
    // ë ˆë²¨ë‹¹ 1ê°œì”© ì¶”ê°€ ë°œë™! (ë ˆë²¨ 1: 1ê°œ, ë ˆë²¨ 2: 2ê°œ, ë ˆë²¨ 3: 3ê°œ...)
    ITEMS: [
        {name: "ë…", icon: "â˜ ï¸", id: "poison",
         apply: function(p) { 
             if (!p.itemLevels.poison) p.itemLevels.poison = 0;
             p.itemLevels.poison++;
             p.poison = true;
             p.poisonDmg = 3 + 2 * p.itemLevels.poison;  // ë°ë¯¸ì§€: 3 + ë ˆë²¨ë‹¹ 2 (0.5ì´ˆë§ˆë‹¤)
         }},
        {name: "ì–¼ìŒ", icon: "â„ï¸", id: "freeze",
         apply: function(p) { 
             if (!p.itemLevels.freeze) p.itemLevels.freeze = 0;
             p.itemLevels.freeze++;
             p.freeze = true;  // ì  ì´ë™ì†ë„ ê°ì†Œ íš¨ê³¼, ë°œë™: 40%
         }},
        {name: "ë ˆì´ì €", icon: "ğŸ’¥", id: "explode",
         apply: function(p) { 
             if (!p.itemLevels.explode) p.itemLevels.explode = 0;
             p.itemLevels.explode++;
             p.explode = true;  // ì  ì²˜ì¹˜ì‹œ ë ˆì´ì € ë°œì‚¬
         }},
        {name: "ë²¼ë½", icon: "âš¡", id: "lightning",
         apply: function(p) { 
             if (!p.itemLevels.lightning) p.itemLevels.lightning = 0;
             p.itemLevels.lightning++;
             // ì  íƒ€ê²©ì‹œ 30% í™•ë¥ ë¡œ ë²¼ë½ ë°œë™
             // ë ˆë²¨ë‹¹ 1ê°œì”© ì¶”ê°€! (ë ˆë²¨ 3 = ë²ˆê°œ 3ê°œ ë™ì‹œ ë°œë™)
             p.lightning = 0.02 * p.itemLevels.lightning;
         }},
        {name: "íšŒì „ ê²€", icon: "ğŸŒ€", id: "spin",
         apply: function(p) { 
             if (!p.itemLevels.spin) p.itemLevels.spin = 0;
             p.itemLevels.spin++;
             p.spinBlade = true;  // ì£¼ë³€ì„ ëŒë©° ì§€ì† ë°ë¯¸ì§€ (0.2ì´ˆë§ˆë‹¤)
             p.spinDmgMultiplier = 0.15 + 0.1 * p.itemLevels.spin;  // ë°ë¯¸ì§€ ë°°ìœ¨
         }},
        {name: "ì¹˜ëª…íƒ€", icon: "ğŸ’¢", id: "crit",
         apply: function(p) { 
             if (!p.itemLevels.crit) p.itemLevels.crit = 0;
             p.itemLevels.crit++;
             p.crit = 0.08 * p.itemLevels.crit;  // ë ˆë²¨ë‹¹ 8% ì¹˜ëª…íƒ€ í™•ë¥  (2ë°° ë°ë¯¸ì§€)
         }},
        {name: "ë‹¤ì¤‘ ë°œì‚¬", icon: "ğŸ¯", id: "multi",
         apply: function(p) { 
             if (!p.itemLevels.multi) p.itemLevels.multi = 0;
             p.itemLevels.multi++;
             p.multishot = p.itemLevels.multi;  // ì¶”ê°€ íˆ¬ì‚¬ì²´ ë°œì‚¬ (ì›ê±°ë¦¬ ìºë¦­í„°)
         }},
        {name: "ìš´ì„", icon: "â˜„ï¸", id: "meteor",
         apply: function(p) { 
             if (!p.itemLevels.meteor) p.itemLevels.meteor = 0;
             p.itemLevels.meteor++;
             // ì  íƒ€ê²©ì‹œ í™•ë¥ ì ìœ¼ë¡œ ìš´ì„ ë‚™í•˜
             // ë ˆë²¨ 1: 5%, ë ˆë²¨ 2: 10%, ë ˆë²¨ 3: 15%...
             // ë ˆë²¨ë‹¹ 1ê°œì”© ì¶”ê°€! (ë ˆë²¨ 3 = ìš´ì„ 3ê°œ ë‚™í•˜)
             p.meteorChance = 0.05 * p.itemLevels.meteor;
             p.meteorDmg = 0.75 * p.itemLevels.meteor;
         }},
        {name: "ì²œì‚¬", icon: "ğŸ‘¼", id: "angel",
         apply: function(p) { 
             if (!p.itemLevels.angel) p.itemLevels.angel = 0;
             p.itemLevels.angel++;
             // ì²œì‚¬ í«ì´ ì—†ìœ¼ë©´ ìƒì„±, ìˆìœ¼ë©´ ë ˆë²¨ì—…
             let angelPet = G.pets.find(pet => pet.type === 'angel');
             if (!angelPet) {
                 G.pets.push(new Pet(p.x, p.y, 'angel', p.itemLevels.angel));
             } else {
                 angelPet.level = p.itemLevels.angel;
                 angelPet.updateStats();
             }
         }},
        {name: "ì•…ë§ˆ", icon: "ğŸ˜ˆ", id: "demon",
         apply: function(p) { 
             if (!p.itemLevels.demon) p.itemLevels.demon = 0;
             p.itemLevels.demon++;
             // ì•…ë§ˆ í«ì´ ì—†ìœ¼ë©´ ìƒì„±, ìˆìœ¼ë©´ ë ˆë²¨ì—…
             let demonPet = G.pets.find(pet => pet.type === 'demon');
             if (!demonPet) {
                 G.pets.push(new Pet(p.x, p.y, 'demon', p.itemLevels.demon));
             } else {
                 demonPet.level = p.itemLevels.demon;
                 demonPet.updateStats();
             }
         }}
    ],
    
    init() {
        this.setupControls();
    },
    
    showCharSelect() {
        document.getElementById('mainScreen').classList.add('hidden');
        document.getElementById('charScreen').classList.remove('hidden');
        
        const grid = document.getElementById('charSelectGrid');
        grid.innerHTML = '';
        
        CHAR_DESIGNS.forEach(char => {
            const div = document.createElement('div');
            div.className = 'character';
            
            const charCanvas = document.createElement('canvas');
            charCanvas.width = 100;
            charCanvas.height = 100;
            const charCtx = charCanvas.getContext('2d');
            charCtx.imageSmoothingEnabled = false;
            charCtx.save();
            charCtx.translate(50, 50);
            char.draw(charCtx, 0, 2);
            charCtx.restore();
            
            const nameDiv = document.createElement('div');
            nameDiv.innerHTML = `<b>${char.name}</b>`;
            
            const descDiv = document.createElement('div');
            descDiv.style.fontSize = '12px';
            descDiv.style.color = '#aaa';
            descDiv.textContent = char.desc;
            
            div.appendChild(charCanvas);
            div.appendChild(nameDiv);
            div.appendChild(descDiv);
            div.onclick = () => this.selectChar(char.type);
            grid.appendChild(div);
        });
    },
    
    setupControls() {
        canvas.addEventListener('mousedown', e => {
            e.preventDefault();
            this.mouse.pressed = true;
            // viewScale ì ìš©í•˜ì—¬ ì‹¤ì œ ê²Œì„ ì¢Œí‘œë¡œ ë³€í™˜
            this.mouse.x = e.clientX * viewScale;
            this.mouse.y = e.clientY * viewScale;
        });
        
        canvas.addEventListener('mousemove', e => {
            if (this.mouse.pressed) {
                this.mouse.x = e.clientX * viewScale;
                this.mouse.y = e.clientY * viewScale;
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            this.mouse.pressed = false;
        });
        
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            this.touch.active = true;
            // viewScale ì ìš©í•˜ì—¬ ì‹¤ì œ ê²Œì„ ì¢Œí‘œë¡œ ë³€í™˜
            this.touch.x = touch.clientX * viewScale;
            this.touch.y = touch.clientY * viewScale;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length > 0) {
                this.touch.x = e.touches[0].clientX * viewScale;
                this.touch.y = e.touches[0].clientY * viewScale;
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            this.touch.active = false;
        }, { passive: false });
        
        document.getElementById('mathAnswer').addEventListener('keypress', e => {
            if (e.key === 'Enter') {
                this.checkMathAnswer();
            }
        });
    },
    
    selectChar(type) {
        document.getElementById('charScreen').classList.add('hidden');
        const design = CHAR_DESIGNS.find(d => d.type === type);
        this.player = new Player(MAP_WIDTH/2, MAP_HEIGHT/2, design);
        this.start();
    },
    
    start() {
        document.getElementById('ui').classList.remove('hidden');
        document.getElementById('minimap').classList.remove('hidden');
        document.getElementById('fullscreenBtn').classList.remove('hidden');
        document.getElementById('soundBtn').classList.remove('hidden');
        
        // í•˜ë“œëª¨ë“œ ì¸ë””ì¼€ì´í„° í‘œì‹œ
        if (hardMode) {
            document.getElementById('hardModeIndicator').classList.remove('hidden');
        } else {
            document.getElementById('hardModeIndicator').classList.add('hidden');
        }
        
        // ê²Œì„ ì´ˆê¸°í™”
        this.score = 0;
        this.stage = 1;
        this.lastBossScore = 0;
        this.bossCount = 0;  // ë³´ìŠ¤ ì¹´ìš´í„° ì´ˆê¸°í™”
        this.nextBossScore = 700;  // ì²« ë³´ìŠ¤ ì¶œí˜„ ì ìˆ˜
        this.boss = null;
        this.pets = [];  // í« ì´ˆê¸°í™”
        this.petProjectiles = [];  // í« íˆ¬ì‚¬ì²´ ì´ˆê¸°í™”
        this.rangedEffectQueue = [];  // ì›ê±°ë¦¬ íš¨ê³¼ í ì´ˆê¸°í™”
        this.enemyProjectiles = [];  // ì  íˆ¬ì‚¬ì²´ ì´ˆê¸°í™”
        
        // ë¸íƒ€ íƒ€ì„ ì´ˆê¸°í™”
        lastFrameTime = 0;
        
        // ë°°ê²½ìŒì•… ì‹œì‘
        SoundManager.startMusic();
        
        this.generateMap();
        this.running = true;
        this.startTime = Date.now();
        this.loop();
    },
    
    generateMap() {
        this.obstacles = [];
        const playerStartX = MAP_WIDTH / 2;
        const playerStartY = MAP_HEIGHT / 2;
        const safeRadius = 150; // í”Œë ˆì´ì–´ ì‹œì‘ ìœ„ì¹˜ ì£¼ë³€ ì•ˆì „ êµ¬ì—­
        
        for (let i = 0; i < 40; i++) {
            let x, y, attempts = 0;
            
            // í”Œë ˆì´ì–´ ì‹œì‘ ìœ„ì¹˜ì™€ ê²¹ì¹˜ì§€ ì•ŠëŠ” ìœ„ì¹˜ ì°¾ê¸°
            do {
                x = Math.random() * MAP_WIDTH;
                y = Math.random() * MAP_HEIGHT;
                attempts++;
            } while (Math.hypot(x - playerStartX, y - playerStartY) < safeRadius && attempts < 20);
            
            // ì•ˆì „í•œ ìœ„ì¹˜ë¥¼ ì°¾ì•˜ê±°ë‚˜ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ì‹œ ìƒì„±
            if (attempts < 20 || Math.hypot(x - playerStartX, y - playerStartY) >= safeRadius) {
                this.obstacles.push({
                    x: x,
                    y: y,
                    size: 30 + Math.random() * 50,
                    type: Math.random() < 0.5 ? 'rock' : 'tree'
                });
            }
        }
    },
    
    updateCamera() {
        let shakeX = 0, shakeY = 0;
        if (this.screenShake > 0) {
            shakeX = (Math.random() - 0.5) * this.screenShake;
            shakeY = (Math.random() - 0.5) * this.screenShake;
            this.screenShake *= 0.9;
            if (this.screenShake < 0.5) this.screenShake = 0;
        }
        
        this.camera.x = this.player.x - cachedCanvasWidth/2 + shakeX;
        this.camera.y = this.player.y - cachedCanvasHeight/2 + shakeY;
        this.camera.x = Math.max(0, Math.min(MAP_WIDTH - cachedCanvasWidth, this.camera.x));
        this.camera.y = Math.max(0, Math.min(MAP_HEIGHT - cachedCanvasHeight, this.camera.y));
        
        // ìºì‹œ ì—…ë°ì´íŠ¸
        cachedCameraX = this.camera.x;
        cachedCameraY = this.camera.y;
    },
    
    isInView(x, y, margin = 0) {
        return x > cachedCameraX - margin && 
               x < cachedCameraX + cachedCanvasWidth + margin && 
               y > cachedCameraY - margin && 
               y < cachedCameraY + cachedCanvasHeight + margin;
    },
    
    spawnEnemies() {
        if (this.enemies.length >= MAX_ENEMIES || this.boss) return;
        
        // ê±°ëŒ€ ëª¬ìŠ¤í„°(íƒ€ì… 5) ìˆ˜ í™•ì¸
        const giantCount = this.enemies.filter(e => e.type === 5).length;
        const MAX_GIANTS = 6;
        
        const count = Math.min(2, MAX_ENEMIES - this.enemies.length);
        
        for (let i = 0; i < count; i++) {
            let x, y;
            const edge = Math.floor(Math.random() * 4);
            
            switch(edge) {
                case 0: x = cachedCameraX - 100; y = cachedCameraY + Math.random() * cachedCanvasHeight; break;
                case 1: x = cachedCameraX + cachedCanvasWidth + 100; y = cachedCameraY + Math.random() * cachedCanvasHeight; break;
                case 2: x = cachedCameraX + Math.random() * cachedCanvasWidth; y = cachedCameraY - 100; break;
                case 3: x = cachedCameraX + Math.random() * cachedCanvasWidth; y = cachedCameraY + cachedCanvasHeight + 100; break;
            }
            
            x = Math.max(50, Math.min(MAP_WIDTH - 50, x));
            y = Math.max(50, Math.min(MAP_HEIGHT - 50, y));
            
            // ë¼ìš´ë“œ 4+ ì—ì„œ ê±°ëŒ€ ëª¬ìŠ¤í„° ìŠ¤í° (8% í™•ë¥ , ìµœëŒ€ 6ë§ˆë¦¬)
            let forceType = null;
            if (this.stage >= 4 && giantCount < MAX_GIANTS && Math.random() < 0.08) {
                forceType = 5;
            }
            
            this.enemies.push(new Enemy(x, y, this.stage, forceType));
        }
    },
    
    spawnBoss() {
        // ===== ë³´ìŠ¤ ì†Œí™˜ =====
        if (this.boss) return;
        
        // ë³´ìŠ¤ ìŠ¤í° ì „ ê²Œì„ ì ê¹ ì¼ì‹œì •ì§€ (ë ‰ ë°©ì§€ ë° ì•ˆì „í•œ ìŠ¤í°)
        this.paused = true;
        
        // ì§„í–‰ ì¤‘ì¸ íˆ¬ì‚¬ì²´ ì œê±°
        this.projectiles = [];
        
        // ì§„í–‰ ì¤‘ì¸ ë² ê¸°/ë§ì¹˜ ì´í™íŠ¸ ì œê±°
        this.slashes = [];
        
        // ê¸°ì¡´ ëª¬ìŠ¤í„° ëª¨ë‘ ì¦‰ì‹œ ì œê±° (ì•„ì´í…œ/ê²½í—˜ì¹˜ ì—†ì´ ê·¸ëƒ¥ ì‚¬ë¼ì§)
        this.enemies = [];
        
        // ë³´ìŠ¤ëŠ” í”Œë ˆì´ì–´ë¡œë¶€í„° 300~400px ë–¨ì–´ì§„ ëœë¤ ë°©í–¥ì—ì„œ ë“±ì¥
        const spawnDistance = 350;
        const spawnAngle = Math.random() * Math.PI * 2;
        let x = this.player.x + Math.cos(spawnAngle) * spawnDistance;
        let y = this.player.y + Math.sin(spawnAngle) * spawnDistance;
        
        // ë§µ ê²½ê³„ ì•ˆìœ¼ë¡œ ì œí•œ
        x = Math.max(100, Math.min(MAP_WIDTH - 100, x));
        y = Math.max(100, Math.min(MAP_HEIGHT - 100, y));
        
        // ë³´ìŠ¤ ë ˆë²¨ì€ ì¶œí˜„ íšŸìˆ˜ë¡œ ê²°ì •
        this.boss = new Boss(x, y, this.bossCount);
        this.enemies.push(this.boss);
        this.bossCount++;  // ë³´ìŠ¤ ì¹´ìš´í„° ì¦ê°€
        
        // 10ë¼ìš´ë“œ: ë³´ìŠ¤ 2ë§ˆë¦¬
        if (this.stage >= 10) {
            const spawnAngle2 = spawnAngle + Math.PI; // ë°˜ëŒ€í¸ì—ì„œ ë“±ì¥
            let x2 = this.player.x + Math.cos(spawnAngle2) * spawnDistance;
            let y2 = this.player.y + Math.sin(spawnAngle2) * spawnDistance;
            x2 = Math.max(100, Math.min(MAP_WIDTH - 100, x2));
            y2 = Math.max(100, Math.min(MAP_HEIGHT - 100, y2));
            
            const secondBoss = new Boss(x2, y2, this.bossCount);
            this.enemies.push(secondBoss);
            this.textParticle(x2, y2 - 150, 'âš ï¸ ë³´ìŠ¤ 2ë§ˆë¦¬! âš ï¸', '#f00', 3);
        }
        
        // 7ë¼ìš´ë“œë¶€í„°: ê±°ì¸ ëª¬ìŠ¤í„° í•¨ê»˜ ë“±ì¥ (ë¼ìš´ë“œë§ˆë‹¤ +2ë§ˆë¦¬, ìµœëŒ€ 10ë§ˆë¦¬)
        if (this.stage >= 7) {
            const giantCount = Math.min(10, (this.stage - 6) * 2); // 7ë¼ìš´ë“œ: 2, 8ë¼ìš´ë“œ: 4, 9ë¼ìš´ë“œ: 6...
            for (let i = 0; i < giantCount; i++) {
                const giantAngle = (Math.PI * 2 * i / giantCount) + Math.random() * 0.5;
                const giantDist = 250 + Math.random() * 150;
                let gx = this.player.x + Math.cos(giantAngle) * giantDist;
                let gy = this.player.y + Math.sin(giantAngle) * giantDist;
                gx = Math.max(50, Math.min(MAP_WIDTH - 50, gx));
                gy = Math.max(50, Math.min(MAP_HEIGHT - 50, gy));
                
                const giant = new Enemy(gx, gy, 5); // type 5 = ê±°ì¸
                this.enemies.push(giant);
            }
            this.textParticle(this.player.x, this.player.y - 100, `ê±°ì¸ ${giantCount}ë§ˆë¦¬!`, '#f80', 2);
        }
        
        this.textParticle(x, y - 150, 'âš ï¸ ë³´ìŠ¤ ë“±ì¥! âš ï¸', '#ff0', 3);
        SoundManager.bossAppear();
        
        // ë³´ìŠ¤ ì „íˆ¬ ìŒì•… ì‹œì‘
        setTimeout(() => {
            SoundManager.startBossMusic();
        }, 900);
        
        // 1ì´ˆ í›„ ê²Œì„ ì¬ê°œ (ë³´ìŠ¤ ë“±ì¥ ì—°ì¶œ ì‹œê°„, ë ‰ ë°©ì§€)
        setTimeout(() => {
            this.paused = false;
        }, 1000);
    },
    
    checkBossSpawn() {
        // ===== ë³´ìŠ¤ ìŠ¤í° ì¡°ê±´ ì²´í¬ =====
        // nextBossScore ê¸°ë°˜ìœ¼ë¡œ ì²´í¬ (ë³´ìŠ¤ ì²˜ì¹˜ ë³´ìƒ ì ìˆ˜ì™€ ë¶„ë¦¬)
        
        if (this.boss) return; // ì´ë¯¸ ë³´ìŠ¤ê°€ ìˆìœ¼ë©´ ìŠ¤í° ì•ˆ í•¨
        
        // nextBossScoreê°€ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
        if (this.nextBossScore === undefined) {
            this.nextBossScore = 700; // ì²« ë³´ìŠ¤ëŠ” 700ì 
        }
        
        if (this.score >= this.nextBossScore) {
            this.spawnBoss();
            
            // ë‹¤ìŒ ë³´ìŠ¤ ì¶œí˜„ ì ìˆ˜ ì„¤ì • (ë¼ìš´ë“œì— ë”°ë¼ ê°„ê²© ì¦ê°€)
            // 1~2ë¼ìš´ë“œ: 3000ì  ê°„ê²©
            // 3ë¼ìš´ë“œ: 4000ì  ê°„ê²©
            // 4ë¼ìš´ë“œ: 6000ì  ê°„ê²©
            // 5ë¼ìš´ë“œ: 8000ì  ê°„ê²©
            // 6ë¼ìš´ë“œ+: 10000ì  ê°„ê²©
            let bossInterval = 3000;
            if (this.stage >= 6) {
                bossInterval = 10000;
            } else if (this.stage >= 5) {
                bossInterval = 8000;
            } else if (this.stage >= 4) {
                bossInterval = 6000;
            } else if (this.stage >= 3) {
                bossInterval = 4000;
            }
            this.nextBossScore = this.score + bossInterval;
        }
    },
    
    showLevelUp() {
        // ===== ë ˆë²¨ì—… í™”ë©´ í‘œì‹œ =====
        this.paused = true;
        SoundManager.levelUp();
        document.getElementById('levelUpScreen').classList.remove('hidden');
        
        const container = document.getElementById('upgrades');
        container.innerHTML = '';
        
        // ìŠ¤í‚¬ ë ˆë²¨ ì¶”ì  ì´ˆê¸°í™”
        if (!this.player.skillLevels) this.player.skillLevels = {};
        
        // ì—…ê·¸ë ˆì´ë“œ ëª©ë¡ì„ ë¬´ì‘ìœ„ë¡œ ì„ì–´ì„œ 3ê°œ ì„ íƒ
        const shuffled = [...this.UPGRADES].sort(() => Math.random() - 0.5);
        shuffled.slice(0, 3).forEach(up => {
            const card = document.createElement('div');
            card.className = 'upgradeCard';
            const currentLevel = this.player.skillLevels[up.name] || 0;
            
            // ì—…ê·¸ë ˆì´ë“œ ì¹´ë“œ HTML ìƒì„± (ë ˆë²¨ í‘œì‹œ í¬í•¨)
            card.innerHTML = `
                <div style="font-size:40px">${up.icon}</div>
                <div>${up.name} Lv.${currentLevel + 1}</div>
            `;
            
            // í´ë¦­ ì‹œ ì—…ê·¸ë ˆì´ë“œ ì ìš©
            card.onclick = () => {
                this.player.skillLevels[up.name] = currentLevel + 1;
                up.apply(this.player);
                document.getElementById('levelUpScreen').classList.add('hidden');
                this.paused = false;
            };
            container.appendChild(card);
        });
    },
    
    generateMathProblem() {
        const level = Math.min(5, Math.floor(this.player.level / 2) + 1);
        let a, b, c, op, op2, question, answer;
        
        // ë¬¸ì œ ìœ í˜• ëœë¤ ì„ íƒ
        const problemType = Math.random();
        
        switch(level) {
            case 1:
                if (problemType < 0.7) {
                    // ê¸°ë³¸ 2ê°œ ìˆ«ì ì—°ì‚°
                    a = Math.floor(Math.random() * 10) + 1;
                    b = Math.floor(Math.random() * 10) + 1;
                    op = Math.random() < 0.5 ? '+' : '-';
                    if (op === '-' && b > a) [a, b] = [b, a];
                    question = `${a} ${op} ${b}`;
                    answer = op === '+' ? a + b : a - b;
                } else {
                    // 3ê°œ ìˆ«ì ë§ì…ˆ (ì‹­ì˜ ìë¦¬ ì´ë‚´)
                    a = Math.floor(Math.random() * 10) + 1;
                    b = Math.floor(Math.random() * 10) + 1;
                    c = Math.floor(Math.random() * 10) + 1;
                    question = `${a} + ${b} + ${c}`;
                    answer = a + b + c;
                }
                break;
            case 2:
                if (problemType < 0.5) {
                    // ê¸°ë³¸ 2ê°œ ìˆ«ì ì—°ì‚°
                    a = Math.floor(Math.random() * 20) + 1;
                    b = Math.floor(Math.random() * 20) + 1;
                    op = ['+', '-', '*'][Math.floor(Math.random() * 3)];
                    if (op === '*') {
                        a = Math.floor(Math.random() * 12) + 1;
                        b = Math.floor(Math.random() * 12) + 1;
                    }
                    if (op === '-' && b > a) [a, b] = [b, a];
                    question = `${a} ${op} ${b}`;
                    answer = op === '+' ? a + b : op === '-' ? a - b : a * b;
                } else if (problemType < 0.8) {
                    // 3ê°œ ìˆ«ì ë§ì…ˆ/ëº„ì…ˆ í˜¼í•© (ì‹­ì˜ ìë¦¬ ì´ë‚´)
                    a = Math.floor(Math.random() * 15) + 5;
                    b = Math.floor(Math.random() * 10) + 1;
                    c = Math.floor(Math.random() * 10) + 1;
                    op = Math.random() < 0.5 ? '+' : '-';
                    op2 = Math.random() < 0.5 ? '+' : '-';
                    
                    // ìŒìˆ˜ ê²°ê³¼ ë°©ì§€
                    let temp = a;
                    if (op === '-') temp -= b; else temp += b;
                    if (op2 === '-' && c > temp) op2 = '+';
                    
                    question = `${a} ${op} ${b} ${op2} ${c}`;
                    temp = a;
                    if (op === '-') temp -= b; else temp += b;
                    if (op2 === '-') temp -= c; else temp += c;
                    answer = temp;
                } else {
                    // 3ê°œ ìˆ«ì ìˆœìˆ˜ ë§ì…ˆ
                    a = Math.floor(Math.random() * 15) + 1;
                    b = Math.floor(Math.random() * 15) + 1;
                    c = Math.floor(Math.random() * 15) + 1;
                    question = `${a} + ${b} + ${c}`;
                    answer = a + b + c;
                }
                break;
            default:
                if (problemType < 0.4) {
                    // ê¸°ë³¸ 2ê°œ ìˆ«ì ì—°ì‚° (ê³ ê¸‰)
                    a = Math.floor(Math.random() * 30) + 1;
                    b = Math.floor(Math.random() * 30) + 1;
                    op = ['+', '-', '*', '/'][Math.floor(Math.random() * 4)];
                    if (op === '/') {
                        answer = Math.floor(Math.random() * 30) + 1;
                        a = b * answer;
                    }
                    if (op === '*') {
                        a = Math.floor(Math.random() * 30) + 1;
                        b = Math.floor(Math.random() * 30) + 1;
                    }
                    if (op === '-' && b > a) [a, b] = [b, a];
                    question = `${a} ${op} ${b}`;
                    if (op !== '/') answer = op === '+' ? a + b : op === '-' ? a - b : a * b;
                } else if (problemType < 0.7) {
                    // 3ê°œ ìˆ«ì ë§ì…ˆ/ëº„ì…ˆ (ì‹­ì˜ ìë¦¬)
                    a = Math.floor(Math.random() * 30) + 10;
                    b = Math.floor(Math.random() * 20) + 1;
                    c = Math.floor(Math.random() * 20) + 1;
                    op = Math.random() < 0.5 ? '+' : '-';
                    op2 = Math.random() < 0.5 ? '+' : '-';
                    
                    // ìŒìˆ˜ ê²°ê³¼ ë°©ì§€
                    let temp = a;
                    if (op === '-') temp -= b; else temp += b;
                    if (op2 === '-' && c > temp) op2 = '+';
                    
                    question = `${a} ${op} ${b} ${op2} ${c}`;
                    temp = a;
                    if (op === '-') temp -= b; else temp += b;
                    if (op2 === '-') temp -= c; else temp += c;
                    answer = temp;
                } else {
                    // 3ê°œ ìˆ«ì ìˆœìˆ˜ ë§ì…ˆ (ë” í° ìˆ˜)
                    a = Math.floor(Math.random() * 30) + 10;
                    b = Math.floor(Math.random() * 30) + 10;
                    c = Math.floor(Math.random() * 20) + 1;
                    question = `${a} + ${b} + ${c}`;
                    answer = a + b + c;
                }
        }
        
        // ì—°ì‚°ì ê¸°í˜¸ë¥¼ ë³´ê¸° ì¢‹ê²Œ ë³€ê²½
        question = question.replace(/\*/g, 'Ã—').replace(/\//g, 'Ã·');
        
        return { question, answer };
    },
    
    showMathScreen(chestX, chestY) {
        // ===== ìˆ˜í•™ ë¬¸ì œ í™”ë©´ í‘œì‹œ =====
        this.paused = true;  // ê²Œì„ ì¼ì‹œì •ì§€
        this.currentChest = { x: chestX, y: chestY };
        SoundManager.chest();
        document.getElementById('mathScreen').classList.remove('hidden');
        
        const problem = this.generateMathProblem();
        this.currentProblem = problem;
        document.getElementById('mathProblem').textContent = problem.question + ' = ?';
        document.getElementById('mathAnswer').value = '';
        document.getElementById('mathAnswer').focus();
    },
    
    checkMathAnswer() {
        // ===== ìˆ˜í•™ ë¬¸ì œ ì •ë‹µ í™•ì¸ =====
        const userAnswer = parseInt(document.getElementById('mathAnswer').value);
        
        if (userAnswer === this.currentProblem.answer) {
            // ì •ë‹µ! ì•„ì´í…œ ì„ íƒ í™”ë©´ìœ¼ë¡œ ì´ë™
            SoundManager.correct();
            document.getElementById('mathScreen').classList.add('hidden');
            this.showItemScreen();  // ì—¬ê¸°ì„œ paused = trueê°€ ë‹¤ì‹œ ì„¤ì •ë¨
            this.textParticle(this.currentChest.x, this.currentChest.y, 'âœ“', '#0f0', 1);
        } else {
            // ì˜¤ë‹µ! ë‹¤ì‹œ ì‹œë„
            SoundManager.wrong();
            this.textParticle(this.player.x, this.player.y, 'âœ—', '#f00', 1);
            document.getElementById('mathAnswer').value = '';
            document.getElementById('mathAnswer').style.borderColor = '#f00';
            setTimeout(() => {
                document.getElementById('mathAnswer').style.borderColor = '#0ff';
            }, 500);
        }
    },
    
    closeMath() {
        // ===== ìˆ˜í•™ ë¬¸ì œ í™”ë©´ ë‹«ê¸° =====
        document.getElementById('mathScreen').classList.add('hidden');
        this.paused = false;  // ê²Œì„ ì¬ê°œ
        this.currentChest = null;
    },
    
    showItemScreen() {
        // ===== ì•„ì´í…œ ì„ íƒ í™”ë©´ í‘œì‹œ =====
        this.paused = true;  // ê²Œì„ ì¼ì‹œì •ì§€
        document.getElementById('itemScreen').classList.remove('hidden');
        
        const container = document.getElementById('items');
        container.innerHTML = '';
        
        const shuffled = [...this.ITEMS].sort(() => Math.random() - 0.5);
        shuffled.slice(0, 3).forEach(item => {
            const card = document.createElement('div');
            card.className = 'upgradeCard';
            const level = this.player.itemLevels[item.id] || 0;
            card.innerHTML = `
                <div style="font-size:40px">${item.icon}</div>
                <div>${item.name}</div>
                <div style="font-size:12px;color:#aaa">Lv.${level} â†’ Lv.${level + 1}</div>
            `;
            card.onclick = () => {
                item.apply(this.player);
                this.textParticle(this.currentChest.x, this.currentChest.y, 'âœ¨', '#ffd700', 1);
                
                document.getElementById('itemScreen').classList.add('hidden');
                this.paused = false;  // ê²Œì„ ì¬ê°œ
                this.currentChest = null;
            };
            container.appendChild(card);
        });
    },
    
    // ===== ì›ê±°ë¦¬ íš¨ê³¼ í ì²˜ë¦¬ (ìµœëŒ€ 5ê°œ ë™ì‹œ ë°œë™) =====
    processRangedEffectQueue() {
        const now = Date.now();
        // 100ms ê°„ê²©ìœ¼ë¡œ íš¨ê³¼ ë°œë™
        if (now - this.lastRangedEffectTime < 100) return;
        
        // íì—ì„œ ìµœëŒ€ 5ê°œ êº¼ë‚´ì„œ ë°œë™
        const effectsToProcess = this.rangedEffectQueue.splice(0, 5);
        if (effectsToProcess.length > 0) {
            this.lastRangedEffectTime = now;
            effectsToProcess.forEach(effect => {
                effect.callback();
            });
        }
    },
    
    // ===== ì›ê±°ë¦¬ íš¨ê³¼ íì— ì¶”ê°€ =====
    queueRangedEffect(callback) {
        this.rangedEffectQueue.push({ callback });
    },
    
    // ===== ë²ˆê°œ ì•„ì´í…œ íš¨ê³¼ ìƒì„± =====
    // ì  íƒ€ê²©ì‹œ í™•ë¥ ì ìœ¼ë¡œ ë°œë™, ë ˆë²¨ì— ë”°ë¼ ë°ë¯¸ì§€ì™€ ë²”ìœ„ ì¦ê°€
    createLightning(x, y, level = 1) {
        // ê²Œì„ì´ ì¼ì‹œì •ì§€ ì¤‘ì´ë©´ íš¨ê³¼ë¥¼ ìƒì„±í•˜ì§€ ì•ŠìŒ
        if (this.paused) {
            return;
        }
        
        const range = 60 + level * 20;
        const damageMultiplier = 0.15 + level * 0.15;  // ë°ë¯¸ì§€: 0.15 + ë ˆë²¨ë‹¹ 0.15
        
        this.effects.push({
            type: 'lightning',
            x: x,
            y: y,
            life: 15,
            segments: this.generateLightningPath(x, y - 300 - level * 50, x, y)
        });
        
        // ë²ˆê°œê°€ ì¹˜ëŠ” ì‹œì ì— ì£¼ë³€ ì ì—ê²Œ ë°ë¯¸ì§€
        setTimeout(() => {
            // ì¼ì‹œì •ì§€ ì¤‘ì´ë©´ ë°ë¯¸ì§€ë¥¼ ì£¼ì§€ ì•ŠìŒ
            if (this.paused) return;
            
            this.enemies.forEach(e => {
                if (Math.hypot(e.x - x, e.y - y) < range) {
                    this.player.dealDamage(e, this.player.damage * damageMultiplier);
                }
            });
        }, 100);
    },
    
    generateLightningPath(x1, y1, x2, y2) {
        const segments = [];
        const steps = 20;
        let lastX = x1;
        let lastY = y1;
        
        for (let i = 1; i <= steps; i++) {
            const progress = i / steps;
            const nextX = x1 + (x2 - x1) * progress + (Math.random() - 0.5) * 40;
            const nextY = y1 + (y2 - y1) * progress;
            
            segments.push({x1: lastX, y1: lastY, x2: nextX, y2: nextY});
            lastX = nextX;
            lastY = nextY;
        }
        
        return segments;
    },
    
    // ===== ìš´ì„ ì•„ì´í…œ íš¨ê³¼ ìƒì„± =====
    // ì  íƒ€ê²©ì‹œ í™•ë¥ ì ìœ¼ë¡œ ë°œë™, ë ˆë²¨ì— ë”°ë¼ í¬ê¸°ì™€ ë°ë¯¸ì§€ ì¦ê°€
    createMeteor(x, y, level = 1) {
        // ê²Œì„ì´ ì¼ì‹œì •ì§€ ì¤‘ì´ë©´ íš¨ê³¼ë¥¼ ìƒì„±í•˜ì§€ ì•ŠìŒ
        if (this.paused) {
            return;
        }
        
        // ëŒ€ê°ì„ ìœ¼ë¡œ ë–¨ì–´ì§€ë„ë¡ ì‹œì‘ ìœ„ì¹˜ ì„¤ì • (ì™¼ìª½ ìœ„ì—ì„œ)
        const startX = x - 300 - level * 30;
        const startY = y - 300 - level * 30;
        
        // ë ˆë²¨ì— ë”°ë¼ í¬ê¸° ì¡°ì •
        const size = 15 + level * 8;
        
        this.effects.push({
            type: 'meteor',
            x: startX,
            y: startY,
            targetX: x,
            targetY: y,
            progress: 0,
            life: 50,
            size: size,
            level: level
        });
        
        // ìš´ì„ì´ ë–¨ì–´ì§€ëŠ” ì‹œì ì— í­ë°œ íš¨ê³¼ ë° ë°ë¯¸ì§€
        setTimeout(() => {
            // ì¼ì‹œì •ì§€ ì¤‘ì´ë©´ ë°ë¯¸ì§€ë¥¼ ì£¼ì§€ ì•ŠìŒ
            if (this.paused) return;
            
            this.screenShake = 8 + level * 3;
            const explosionRadius = 60 + level * 20;
            const damageMultiplier = 0.3 + level * 0.2;  // ë°ë¯¸ì§€: 0.3 + ë ˆë²¨ë‹¹ 0.2
            
            // ìš´ì„ ì „ìš© í­ë°œ íš¨ê³¼
            this.effects.push({
                type: 'meteorExplosion',
                x: x,
                y: y,
                radius: 0,
                maxRadius: explosionRadius,
                life: 35,
                level: level
            });
            
            // í­ë°œ ë²”ìœ„ ë‚´ ì ì—ê²Œ ë°ë¯¸ì§€ ë° í™”ìƒ íš¨ê³¼
            this.enemies.forEach(e => {
                if (Math.hypot(e.x - x, e.y - y) < explosionRadius) {
                    this.player.dealDamage(e, this.player.damage * damageMultiplier);
                    e.burning = true;
                    e.burningTime = 40 + level * 15;
                }
            });
        }, 800);
    },
    
    // ===== ì–¼ìŒ ìŠ¤íŒŒì´í¬ ì•„ì´í…œ íš¨ê³¼ ìƒì„± =====
    // ì  íƒ€ê²©ì‹œ í™•ë¥ ì ìœ¼ë¡œ ë°œë™, ë ˆë²¨ì— ë”°ë¼ ë†’ì´ì™€ ë°ë¯¸ì§€ ì¦ê°€
    createIceSpike(x, y, level = 1) {
        // ê²Œì„ì´ ì¼ì‹œì •ì§€ ì¤‘ì´ë©´ íš¨ê³¼ë¥¼ ìƒì„±í•˜ì§€ ì•ŠìŒ
        if (this.paused) {
            return;
        }
        
        const maxHeight = 60 + level * 20;
        const range = 40 + level * 15;
        const damageMultiplier = 0.15 + level * 0.1;  // ë°ë¯¸ì§€: 0.15 + ë ˆë²¨ë‹¹ 0.1
        
        this.effects.push({
            type: 'icespike',
            x: x,
            y: y,
            height: 0,
            maxHeight: maxHeight,
            life: 30
        });
        
        // ì–¼ìŒ ìŠ¤íŒŒì´í¬ê°€ ì†Ÿì•„ì˜¤ë¥´ëŠ” ì‹œì ì— ì£¼ë³€ ì ì—ê²Œ ë°ë¯¸ì§€ ë° ë¹™ê²° íš¨ê³¼
        setTimeout(() => {
            // ì¼ì‹œì •ì§€ ì¤‘ì´ë©´ ë°ë¯¸ì§€ë¥¼ ì£¼ì§€ ì•ŠìŒ
            if (this.paused) return;
            
            this.enemies.forEach(e => {
                if (Math.hypot(e.x - x, e.y - y) < range) {
                    this.player.dealDamage(e, this.player.damage * damageMultiplier);
                    e.frozen = true;
                    e.frozenSpeed = e.speed;
                    e.speed *= 0.2;  // ì´ë™ì†ë„ 80% ê°ì†Œ
                    setTimeout(() => {
                        if (e.frozen) {
                            e.frozen = false;
                            e.speed = e.frozenSpeed;
                        }
                    }, 1500 + level * 200);  // ì§€ì†ì‹œê°„: 1.5ì´ˆ + ë ˆë²¨ë‹¹ 0.2ì´ˆ
                }
            });
        }, 200);
    },
    
    textParticle(x, y, text, color, scale = 1) {
        this.particles.push({
            x: x,
            y: y,
            text: text,
            color: color,
            life: 40,
            scale: scale
        });
    },
    
    updateUI() {
        document.getElementById('level').textContent = this.player.level;
        document.getElementById('score').textContent = Math.floor(this.score);
        document.getElementById('stage').textContent = this.stage;
        document.getElementById('time').textContent = Math.floor((Date.now() - this.startTime) / 1000);
        document.getElementById('hp').style.width = (this.player.hp / this.player.maxHp * 100) + '%';
        
        // ê²½í—˜ì¹˜ ë°” ë„ˆë¹„ë¥¼ 100%ë¡œ ì œí•œ (ì˜¤ë²„í”Œë¡œìš° ë°©ì§€)
        const expPercent = Math.min(100, (this.player.exp / this.player.expNext * 100));
        document.getElementById('exp').style.width = expPercent + '%';
    },
    
    drawMinimap() {
        minimapCtx.fillStyle = '#000';
        minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        
        const scale = minimapCanvas.width / MAP_WIDTH;
        
        minimapCtx.fillStyle = '#0f0';
        minimapCtx.fillRect(this.player.x * scale - 2, this.player.y * scale - 2, 4, 4);
        
        minimapCtx.fillStyle = '#f00';
        this.enemies.forEach(e => {
            if (e.isBoss) {
                minimapCtx.fillRect(e.x * scale - 3, e.y * scale - 3, 6, 6);
            } else {
                minimapCtx.fillRect(e.x * scale - 1, e.y * scale - 1, 2, 2);
            }
        });
        
        minimapCtx.fillStyle = '#ff0';
        this.items.forEach(item => {
            minimapCtx.fillRect(item.x * scale - 1, item.y * scale - 1, 2, 2);
        });
    },
    
    gameOver() {
        this.running = false;
        document.getElementById('gameOverScreen').classList.remove('hidden');
        document.getElementById('finalStats').innerHTML = `
            <div>ìµœì¢… ì ìˆ˜: ${Math.floor(this.score)}</div>
            <div>ë ˆë²¨: ${this.player.level}</div>
            <div>ìƒì¡´ ì‹œê°„: ${Math.floor((Date.now() - this.startTime) / 1000)}ì´ˆ</div>
        `;
    },
    
    loop(timestamp = 0) {
        if (!this.running) return;
        
        // ===== ë¸íƒ€ íƒ€ì„ ê³„ì‚° (í”„ë ˆì„ ì†ë„ ì¼ì •í•˜ê²Œ ìœ ì§€) =====
        if (!lastFrameTime) lastFrameTime = timestamp;
        const deltaTime = timestamp - lastFrameTime;
        
        // ë„ˆë¬´ ë¹ ë¥´ë©´ ìŠ¤í‚µ (60fps ìœ ì§€)
        if (deltaTime < FRAME_TIME * 0.8) {
            requestAnimationFrame((t) => this.loop(t));
            return;
        }
        
        // ë¸íƒ€ ê¸°ë°˜ ì†ë„ ì¡°ì ˆ (16.67ms ê¸°ì¤€)
        gameSpeedMultiplier = Math.min(deltaTime / FRAME_TIME, 2);  // ìµœëŒ€ 2ë°°ì† ì œí•œ
        // NaN ë°©ì§€
        if (isNaN(gameSpeedMultiplier) || gameSpeedMultiplier <= 0) {
            gameSpeedMultiplier = 1;
        }
        lastFrameTime = timestamp;
        
        if (!this.paused) {
            this.updateCamera();
            
            // ===== ì”ë””ë°­ ë°°ê²½ (ë‹¨ìƒ‰, ëˆˆ í¸ì•ˆí•˜ê²Œ) =====
            ctx.fillStyle = '#B8D8BA';  // ì—°í•œ ë¯¼íŠ¸ ê·¸ë¦° (ë¶€ë“œëŸ½ê³  ë°ìŒ)
            ctx.fillRect(0, 0, cachedCanvasWidth, cachedCanvasHeight);
            
            // ì”ë”” íŒ¨í„´ (ì•„ì£¼ ì—°í•˜ê²Œ) - ìµœì í™”: í•œ ë²ˆì— ê·¸ë¦¬ê¸°
            ctx.strokeStyle = 'rgba(100,150,100,0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const gridOffsetX = -cachedCameraX % 50;
            const gridOffsetY = -cachedCameraY % 50;
            
            for (let x = gridOffsetX; x < cachedCanvasWidth; x += 50) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, cachedCanvasHeight);
            }
            for (let y = gridOffsetY; y < cachedCanvasHeight; y += 50) {
                ctx.moveTo(0, y);
                ctx.lineTo(cachedCanvasWidth, y);
            }
            ctx.stroke();
            
            const now = Date.now();
            
            const spawnInterval = Math.max(400, 1200 / (1 + this.stage * 0.2));
            // ===== ì¼ë°˜ ëª¬ìŠ¤í„° ìŠ¤í° (ë³´ìŠ¤ ì „íˆ¬ ì¤‘ì—ëŠ” ìŠ¤í° ì•ˆ í•¨) =====
            if (!this.boss && now - this.lastSpawn > spawnInterval && this.enemies.length < MAX_ENEMIES) {
                this.spawnEnemies();
                this.lastSpawn = now;
            }
            
            // ===== ë³´ìŠ¤ ìŠ¤í° ì²´í¬ =====
            this.checkBossSpawn();
            
            // ===== ì›ê±°ë¦¬ íš¨ê³¼ í ì²˜ë¦¬ =====
            this.processRangedEffectQueue();
            
            this.player.update();
            
            // ===== í« ì—…ë°ì´íŠ¸ =====
            this.pets.forEach(pet => pet.update());
            
            // ===== í« íˆ¬ì‚¬ì²´ ì—…ë°ì´íŠ¸ =====
            this.petProjectiles = this.petProjectiles.filter(p => p.update());
            
            // ===== ì  ì—…ë°ì´íŠ¸ ë° ì œê±° =====
            this.enemies = this.enemies.filter(e => {
                try {
                    e.update();
                } catch (err) {
                    console.error('Enemy update error:', err);
                    // ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ë³´ìŠ¤ëŠ” ìœ ì§€
                    if (e.isBoss) return true;
                }
                
                // HPê°€ NaNì´ë©´ ìœ ì§€ (ë²„ê·¸ ë°©ì§€)
                if (isNaN(e.hp)) {
                    console.warn('Enemy HP is NaN, keeping enemy');
                    e.hp = e.maxHp || 100; // HP ë³µêµ¬
                    return true;
                }
                
                if (e.hp <= 0) {
                    if (e.isBoss) {
                        // ë‚¨ì€ ë³´ìŠ¤ ìˆ˜ í™•ì¸ (í˜„ì¬ ì£½ì€ ë³´ìŠ¤ ì œì™¸)
                        const remainingBosses = this.enemies.filter(enemy => enemy.isBoss && enemy !== e && enemy.hp > 0).length;
                        
                        if (remainingBosses === 0) {
                            // ë§ˆì§€ë§‰ ë³´ìŠ¤ ì²˜ì¹˜! ë³´ìŠ¤ í”Œë˜ê·¸ í•´ì œ ë° ì¼ë°˜ ëª¬ìŠ¤í„° ìŠ¤í° ì¬ê°œ
                            this.boss = null;
                            
                            // ì›ë˜ ë°°ê²½ìŒì•…ìœ¼ë¡œ ë³µê·€
                            SoundManager.startMusic();
                            
                            // ë¼ìš´ë“œ ì¦ê°€!
                            this.stage++;
                            this.textParticle(this.player.x, this.player.y - 80, `ğŸ‰ ë¼ìš´ë“œ ${this.stage} ëŒì…! ğŸ‰`, '#ff0', 2);
                            
                            // 0.5ì´ˆ í›„ ìƒˆë¡œìš´ ì¼ë°˜ ëª¬ìŠ¤í„° ì†Œí™˜
                            setTimeout(() => {
                                this.spawnEnemies();
                            }, 500);
                        } else {
                            // ë³´ìŠ¤ê°€ ì•„ì§ ë‚¨ì•„ìˆìŒ
                            this.textParticle(e.x, e.y - 50, `ë³´ìŠ¤ ì²˜ì¹˜! (ë‚¨ì€ ë³´ìŠ¤: ${remainingBosses})`, '#ff0', 1.5);
                        }
                    }
                }
                return e.hp > 0;
            });
            
            // ë³´ìŠ¤ ìƒíƒœ ë™ê¸°í™”: ë°°ì—´ì— ë³´ìŠ¤ê°€ ì—†ìœ¼ë©´ this.bossë„ nullë¡œ
            if (this.boss && !this.enemies.some(e => e.isBoss)) {
                console.warn('Boss missing from enemies array, resetting boss state');
                this.boss = null;
                SoundManager.startMusic();
            }
            
            this.projectiles = this.projectiles.filter(p => p.update());
            
            // ===== ì  íˆ¬ì‚¬ì²´ ì—…ë°ì´íŠ¸ =====
            this.enemyProjectiles = this.enemyProjectiles || [];
            this.enemyProjectiles = this.enemyProjectiles.filter(ep => {
                ep.x += ep.vx * gameSpeedMultiplier;
                ep.y += ep.vy * gameSpeedMultiplier;
                ep.life -= gameSpeedMultiplier;
                
                // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ ê²€ì‚¬ (ëŒì€ ë” í° ì¶©ëŒ ë²”ìœ„)
                const hitRadius = ep.isRock ? (ep.size || 18) : 25;
                const dist = Math.hypot(ep.x - this.player.x, ep.y - this.player.y);
                if (dist < hitRadius + 15) {
                    this.player.takeDamage(ep.damage);
                    return false;
                }
                
                return ep.life > 0;
            });
            
            this.slashes = this.slashes.filter(s => {
                s.life--;
                s.opacity = s.life / 15;
                return s.life > 0;
            });
            
            this.items = this.items.filter(item => {
                // ê²Œì„ì´ ì¼ì‹œì •ì§€ ìƒíƒœë©´ ì•„ì´í…œ ìˆ˜ì§‘ ì•ˆí•¨
                if (this.paused) return true;
                
                const dist = Math.hypot(this.player.x - item.x, this.player.y - item.y);
                if (dist < 40) {
                    if (item.type === 'chest') {
                        this.showMathScreen(item.x, item.y);
                    } else {
                        SoundManager.item();
                        this.player.gainExp(item.value);
                    }
                    return false;
                }
                return true;
            });
            
            this.particles = this.particles.filter(p => {
                p.y -= 2;
                p.life--;
                return p.life > 0;
            });
            
            this.effects = this.effects.filter(e => {
                e.life--;
                
                if (e.type === 'meteor') {
                    // ëŒ€ê°ì„ ìœ¼ë¡œ ë” ë¹ ë¥´ê²Œ ë–¨ì–´ì§€ë„ë¡
                    e.progress += 0.04;
                    const speed = 0.04 + e.progress * 0.02;  // ê°€ì†
                    e.x = e.x + (e.targetX - e.x) * speed;
                    e.y = e.y + (e.targetY - e.y) * speed;
                } else if (e.type === 'beam') {
                    // ë¹”ì´ í™•ì¥ë˜ëŠ” ì• ë‹ˆë©”ì´ì…˜ (êµµê¸° ì ˆë°˜ìœ¼ë¡œ ì¶•ì†Œ)
                    if (e.width < 15) {
                        e.width += 1.5;
                    }
                } else if (e.type === 'poisoncloud') {
                    // ë… êµ¬ë¦„ì´ 30í”„ë ˆì„(0.5ì´ˆ)ë§ˆë‹¤ ë°ë¯¸ì§€ë¥¼ ì¤Œ
                    if (e.life % 30 === 0) {
                        this.enemies.forEach(enemy => {
                            const dist = Math.hypot(enemy.x - e.x, enemy.y - e.y);
                            if (dist < e.radius) {
                                enemy.hp -= e.damage; // 0.5ì´ˆë§ˆë‹¤ ë… ë°ë¯¸ì§€
                                if (enemy.hp > 0) {
                                    this.textParticle(enemy.x, enemy.y, `-${Math.round(e.damage)}`, '#0a0', 0.6);
                                }
                            }
                        });
                    }
                } else if (e.type === 'icespike') {
                    if (e.height < e.maxHeight) {
                        e.height += 4;
                    }
                }
                
                return e.life > 0;
            });
            
            ctx.save();
            ctx.translate(-this.camera.x, -this.camera.y);
            
            this.obstacles.forEach(obs => {
                if (this.isInView(obs.x, obs.y, 100)) {
                    if (obs.type === 'rock') {
                        ctx.fillStyle = '#555';
                        ctx.beginPath();
                        ctx.arc(obs.x, obs.y, obs.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#666';
                        ctx.beginPath();
                        ctx.arc(obs.x - 5, obs.y - 5, obs.size * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillStyle = '#2a4';
                        ctx.fillRect(obs.x - 10, obs.y, 20, obs.size);
                        ctx.fillStyle = '#3b5';
                        ctx.beginPath();
                        ctx.arc(obs.x, obs.y - obs.size/2, obs.size * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
            
            this.items.forEach(item => {
                if (this.isInView(item.x, item.y, 50)) {
                    if (item.type === 'chest') {
                        const pulse = Math.sin(Date.now() / 200) * 3;
                        const p = 3;
                        
                        ctx.save();
                        ctx.translate(item.x, item.y + pulse);
                        
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.fillRect(-6*p, 4*p, 12*p, 2*p);
                        
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(-6*p, -4*p, 12*p, 8*p);
                        
                        ctx.fillStyle = '#A0522D';
                        ctx.fillRect(-6*p, -6*p, 12*p, 3*p);
                        
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(-7*p, -4*p, 14*p, 1*p);
                        ctx.fillRect(-7*p, 3*p, 14*p, 1*p);
                        ctx.fillRect(-7*p, -4*p, 1*p, 8*p);
                        ctx.fillRect(6*p, -4*p, 1*p, 8*p);
                        
                        ctx.fillStyle = '#DAA520';
                        ctx.fillRect(-1*p, 0, 2*p, 3*p);
                        ctx.fillRect(-2*p, 1*p, 4*p, 1*p);
                        
                        ctx.restore();
                    } else {
                        ctx.fillStyle = '#0f0';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#0f0';
                        ctx.beginPath();
                        ctx.arc(item.x, item.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }
            });
            
            this.effects.forEach(effect => {
                // attackWarningì€ ë²”ìœ„ê°€ ë„“ìœ¼ë¯€ë¡œ ë” í° ë²”ìœ„ë¡œ ì²´í¬
                const viewRange = (effect.type === 'attackWarning' || effect.type === 'laserWarning') ? 500 : 200;
                if (!this.isInView(effect.x, effect.y, viewRange)) return;
                
                ctx.save();
                
                if (effect.type === 'lightning') {
                    const alpha = effect.life / 15;
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 4;
                    
                    effect.segments.forEach(seg => {
                        ctx.beginPath();
                        ctx.moveTo(seg.x1, seg.y1);
                        ctx.lineTo(seg.x2, seg.y2);
                        ctx.stroke();
                    });
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    effect.segments.forEach(seg => {
                        ctx.beginPath();
                        ctx.moveTo(seg.x1, seg.y1);
                        ctx.lineTo(seg.x2, seg.y2);
                        ctx.stroke();
                    });
                } else if (effect.type === 'meteor') {
                    const baseSize = effect.size || 15;
                    const size = baseSize + effect.progress * baseSize * 0.5;
                    const level = effect.level || 1;
                    
                    // ëŒ€ê°ì„  ê¼¬ë¦¬ (ì™¼ìª½ ìœ„ë¡œ)
                    for (let i = 0; i < 6; i++) {
                        const trailSize = size * (1 - i * 0.15);
                        const trailOffset = i * 15;
                        ctx.globalAlpha = 0.6 - i * 0.1;
                        ctx.fillStyle = i < 2 ? '#FF4500' : '#FF6347';
                        ctx.beginPath();
                        ctx.arc(effect.x - trailOffset, effect.y - trailOffset, trailSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // ìš´ì„ ë³¸ì²´ ê·¸ë¦¼ì
                    ctx.globalAlpha = 0.8;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#FF4500';
                    
                    // ì™¸ê³½ ë¶ˆê½ƒ
                    ctx.fillStyle = '#8B0000';
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, size * 1.2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ìš´ì„ ë³¸ì²´
                    ctx.fillStyle = '#4a2c00';
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ìš´ì„ ë°ì€ ë¶€ë¶„
                    ctx.fillStyle = '#FF4500';
                    ctx.beginPath();
                    ctx.arc(effect.x - size * 0.3, effect.y - size * 0.3, size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ë¶ˆê½ƒ ì´í™íŠ¸
                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath();
                    ctx.arc(effect.x - size * 0.4, effect.y - size * 0.4, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                } else if (effect.type === 'beam') {
                    const alpha = effect.life / 20;
                    ctx.globalAlpha = alpha;
                    
                    // ë¹” ê·¸ë¦¬ê¸° (í”Œë ˆì´ì–´ì—ì„œ ì‹œì‘)
                    ctx.save();
                    ctx.translate(effect.startX, effect.startY);
                    ctx.rotate(effect.angle);
                    
                    // ì™¸ê³½ ê´‘ì„ 
                    const gradient = ctx.createLinearGradient(0, -effect.width/2, 0, effect.width/2);
                    gradient.addColorStop(0, 'transparent');
                    gradient.addColorStop(0.3, 'rgba(255,100,100,0.8)');
                    gradient.addColorStop(0.5, 'rgba(255,255,255,1)');
                    gradient.addColorStop(0.7, 'rgba(255,100,100,0.8)');
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, -effect.width/2, effect.length, effect.width);
                    
                    // ì¤‘ì‹¬ ë¹”
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.fillRect(0, -effect.width/4, effect.length, effect.width/2);
                    
                    ctx.restore();
                } else if (effect.type === 'poisoncloud') {
                    const alpha = 0.3 + Math.sin(Date.now() / 100) * 0.1;
                    ctx.globalAlpha = alpha * (effect.life / 120);
                    
                    // ë… êµ¬ë¦„ ê·¸ë¦¬ê¸°
                    const gradient = ctx.createRadialGradient(effect.x, effect.y, 0, effect.x, effect.y, effect.radius);
                    gradient.addColorStop(0, 'rgba(50,200,50,0.6)');
                    gradient.addColorStop(0.5, 'rgba(30,150,30,0.4)');
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ë… ì…ì
                    for (let i = 0; i < 5; i++) {
                        const particleX = effect.x + Math.cos(Date.now() / 200 + i) * effect.radius * 0.5;
                        const particleY = effect.y + Math.sin(Date.now() / 150 + i) * effect.radius * 0.5;
                        ctx.fillStyle = 'rgba(100,255,100,0.5)';
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (effect.type === 'icespike') {
                    ctx.globalAlpha = effect.life / 30;
                    
                    // ì–¼ìŒ ìŠ¤íŒŒì´í¬ ê·¸ë¦¬ê¸°
                    ctx.fillStyle = '#87CEEB';
                    ctx.beginPath();
                    ctx.moveTo(effect.x, effect.y);
                    ctx.lineTo(effect.x - 15, effect.y);
                    ctx.lineTo(effect.x, effect.y - effect.height);
                    ctx.lineTo(effect.x + 15, effect.y);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#B0E0E6';
                    ctx.beginPath();
                    ctx.moveTo(effect.x, effect.y);
                    ctx.lineTo(effect.x + 15, effect.y);
                    ctx.lineTo(effect.x + 5, effect.y - effect.height * 0.8);
                    ctx.closePath();
                    ctx.fill();
                } else if (effect.type === 'hammerImpact') {
                    effect.radius += 3;
                    const alpha = effect.life / 15;
                    ctx.globalAlpha = alpha;
                    
                    // ì¶©ê²©íŒŒ ê·¸ë¦¬ê¸°
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (effect.type === 'shockwave') {
                    // ë³´ìŠ¤ ìŠ¬ë¨ ì¶©ê²©íŒŒ
                    effect.radius += (effect.maxRadius - effect.radius) * 0.15;
                    const alpha = effect.life / 20;
                    ctx.globalAlpha = alpha;
                    
                    // ì¶©ê²©íŒŒ ì™¸ê³½
                    ctx.strokeStyle = '#ff4400';
                    ctx.lineWidth = 8;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ë‚´ë¶€ ì›
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ì¤‘ì‹¬ í­ë°œ
                    const centerGradient = ctx.createRadialGradient(effect.x, effect.y, 0, effect.x, effect.y, effect.radius * 0.3);
                    centerGradient.addColorStop(0, 'rgba(255,200,0,0.6)');
                    centerGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = centerGradient;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                } else if (effect.type === 'laserWarning') {
                    // ë ˆì´ì € ì˜ˆê³  ê²½ê³ ì„ 
                    // ì•ˆì „ ì²´í¬: angleì´ ìœ íš¨í•œì§€ í™•ì¸
                    if (isNaN(effect.angle) || effect.maxLife === undefined || effect.maxLife === 0) {
                        effect.life = 0; // ì˜ëª»ëœ ì´í™íŠ¸ëŠ” ì œê±°
                        return;
                    }
                    
                    const alpha = (effect.life / effect.maxLife) * 0.8;
                    const flashIntensity = Math.sin(effect.life * 0.5) * 0.3 + 0.7; // ê¹œë¹¡ì„ íš¨ê³¼
                    ctx.globalAlpha = alpha * flashIntensity;
                    
                    // ê²½ê³ ì„  ê¸¸ì´
                    const lineLength = 800;
                    const endX = effect.x + Math.cos(effect.angle) * lineLength;
                    const endY = effect.y + Math.sin(effect.angle) * lineLength;
                    
                    // ë„“ì€ ê²½ê³  ì˜ì—­ (ë°˜íˆ¬ëª… ë¹¨ê°•)
                    ctx.save();
                    ctx.translate(effect.x, effect.y);
                    ctx.rotate(effect.angle);
                    
                    const warningGradient = ctx.createLinearGradient(0, -40, 0, 40);
                    warningGradient.addColorStop(0, 'transparent');
                    warningGradient.addColorStop(0.3, 'rgba(255,0,0,0.3)');
                    warningGradient.addColorStop(0.5, 'rgba(255,50,0,0.5)');
                    warningGradient.addColorStop(0.7, 'rgba(255,0,0,0.3)');
                    warningGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = warningGradient;
                    ctx.fillRect(0, -40, lineLength, 80);
                    
                    ctx.restore();
                    
                    // ì¤‘ì‹¬ ê²½ê³ ì„  (ë°ì€ ë¹¨ê°•)
                    ctx.strokeStyle = `rgba(255,${100 + flashIntensity * 100},0,${alpha})`;
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff0000';
                    ctx.beginPath();
                    ctx.moveTo(effect.x, effect.y);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // ê²½ê³  í…ìŠ¤íŠ¸
                    if (effect.life > effect.maxLife * 0.5) {
                        ctx.font = 'bold 20px sans-serif';
                        ctx.fillStyle = `rgba(255,255,0,${alpha})`;
                        ctx.textAlign = 'center';
                        const textX = effect.x + Math.cos(effect.angle) * 150;
                        const textY = effect.y + Math.sin(effect.angle) * 150;
                        ctx.fillText('âš ï¸ ìœ„í—˜! âš ï¸', textX, textY);
                    }
                    
                    ctx.shadowBlur = 0;
                } else if (effect.type === 'attackWarning') {
                    // ë³´ìŠ¤ ì›ê±°ë¦¬ ê³µê²© ë²”ìœ„ í‘œì‹œ (ë¶€ì±„ê¼´)
                    // ì•ˆì „ ì²´í¬: í•„ìˆ˜ ì†ì„± í™•ì¸
                    if (isNaN(effect.angle) || effect.maxLife === undefined || effect.maxLife === 0 ||
                        effect.spreadAngle === undefined || effect.range === undefined) {
                        effect.life = 0;
                        return;
                    }
                    
                    const alpha = (effect.life / effect.maxLife) * 0.9;
                    const flashIntensity = Math.sin(effect.life * 0.5) * 0.3 + 0.7; // ë” ê°•í•œ ê¹œë¹¡ì„
                    ctx.globalAlpha = alpha * flashIntensity;
                    
                    ctx.save();
                    ctx.translate(effect.x, effect.y);
                    
                    // ë¶€ì±„ê¼´ ë²”ìœ„ í‘œì‹œ
                    const startAngle = effect.angle - effect.spreadAngle / 2;
                    const endAngle = effect.angle + effect.spreadAngle / 2;
                    
                    // ìƒ‰ìƒ íŒŒì‹± (hex to rgb)
                    const color = effect.color || '#ff8800';
                    let r = 255, g = 136, b = 0;
                    if (color === '#ff00ff') { r = 255; g = 0; b = 255; }
                    
                    // ë°”ë‹¥ì— ë¶€ì±„ê¼´ ì˜ì—­ í‘œì‹œ (ë” ì§„í•˜ê²Œ)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, effect.range, startAngle, endAngle);
                    ctx.closePath();
                    
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, effect.range);
                    gradient.addColorStop(0, `rgba(${r},${g},${b},0.6)`);
                    gradient.addColorStop(0.5, `rgba(${r},${g},${b},0.4)`);
                    gradient.addColorStop(1, `rgba(${r},${g},${b},0.1)`);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // í…Œë‘ë¦¬ (ë” ë‘ê»ê³  ë°ê²Œ)
                    ctx.strokeStyle = `rgba(${r},${g},${b},0.9)`;
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    
                    // ë¶€ì±„ê¼´ ì–‘ìª½ ê²½ê³„ì„ 
                    ctx.strokeStyle = `rgba(255,255,255,0.7)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(startAngle) * effect.range, Math.sin(startAngle) * effect.range);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(endAngle) * effect.range, Math.sin(endAngle) * effect.range);
                    ctx.stroke();
                    
                    // ë°©í–¥ í‘œì‹œ í™”ì‚´í‘œ (ì¤‘ì•™)
                    ctx.strokeStyle = `rgba(255,255,0,0.9)`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(effect.angle) * effect.range * 0.7, Math.sin(effect.angle) * effect.range * 0.7);
                    ctx.stroke();
                    
                    // í™”ì‚´í‘œ ë¨¸ë¦¬
                    const arrowX = Math.cos(effect.angle) * effect.range * 0.7;
                    const arrowY = Math.sin(effect.angle) * effect.range * 0.7;
                    ctx.fillStyle = `rgba(255,255,0,0.9)`;
                    ctx.beginPath();
                    ctx.moveTo(arrowX, arrowY);
                    ctx.lineTo(arrowX - Math.cos(effect.angle - 0.3) * 20, arrowY - Math.sin(effect.angle - 0.3) * 20);
                    ctx.lineTo(arrowX - Math.cos(effect.angle + 0.3) * 20, arrowY - Math.sin(effect.angle + 0.3) * 20);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                } else if (effect.type === 'explosion') {
                    effect.radius += (effect.maxRadius - effect.radius) * 0.2;
                    const alpha = effect.life / 20;
                    ctx.globalAlpha = alpha;
                    
                    // í­ë°œ ì¤‘ì‹¬ ë°ì€ ë¹›
                    const explosionGradient = ctx.createRadialGradient(effect.x, effect.y, 0, effect.x, effect.y, effect.radius);
                    explosionGradient.addColorStop(0, 'rgba(255,200,50,0.8)');
                    explosionGradient.addColorStop(0.4, 'rgba(255,100,0,0.6)');
                    explosionGradient.addColorStop(0.7, 'rgba(200,50,0,0.3)');
                    explosionGradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = explosionGradient;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ì™¸ê³½ ì¶©ê²©íŒŒ
                    ctx.strokeStyle = '#FF6600';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ë‚´ë¶€ ë°ì€ ì¶©ê²©íŒŒ
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ì¤‘ì•™ ì„¬ê´‘
                    if (effect.life > 10) {
                        const flashGradient = ctx.createRadialGradient(effect.x, effect.y, 0, effect.x, effect.y, 30);
                        flashGradient.addColorStop(0, 'rgba(255,255,255,0.9)');
                        flashGradient.addColorStop(0.5, 'rgba(255,215,0,0.6)');
                        flashGradient.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = flashGradient;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, 30, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (effect.type === 'meteorExplosion') {
                    // ìš´ì„ ì „ìš© í­ë°œ íš¨ê³¼ - ë” í™”ë ¤í•˜ê³  ì‹¤ê°ë‚˜ê²Œ
                    effect.radius += (effect.maxRadius - effect.radius) * 0.15;
                    const alpha = effect.life / 35;
                    const level = effect.level || 1;
                    
                    ctx.globalAlpha = alpha;
                    
                    // ë•… ì¶©ê²©íŒŒ (ê°ˆë¼ì§€ëŠ” íš¨ê³¼)
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 4 + level;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const crackLength = effect.radius * 0.8;
                        ctx.beginPath();
                        ctx.moveTo(effect.x, effect.y);
                        ctx.lineTo(
                            effect.x + Math.cos(angle) * crackLength,
                            effect.y + Math.sin(angle) * crackLength
                        );
                        ctx.stroke();
                    }
                    
                    // ì™¸ê³½ í™”ì—¼ ë§
                    const fireGradient = ctx.createRadialGradient(effect.x, effect.y, effect.radius * 0.3, effect.x, effect.y, effect.radius);
                    fireGradient.addColorStop(0, 'rgba(255,255,200,0.9)');
                    fireGradient.addColorStop(0.2, 'rgba(255,200,50,0.8)');
                    fireGradient.addColorStop(0.5, 'rgba(255,100,0,0.6)');
                    fireGradient.addColorStop(0.8, 'rgba(180,50,0,0.4)');
                    fireGradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = fireGradient;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ë¶ˆê½ƒ íŒŒí‹°í´
                    for (let i = 0; i < 12 + level * 3; i++) {
                        const particleAngle = (i / (12 + level * 3)) * Math.PI * 2 + effect.life * 0.1;
                        const particleDist = effect.radius * (0.5 + Math.sin(effect.life * 0.3 + i) * 0.3);
                        const particleX = effect.x + Math.cos(particleAngle) * particleDist;
                        const particleY = effect.y + Math.sin(particleAngle) * particleDist;
                        const particleSize = 5 + level * 2 + Math.sin(effect.life * 0.5 + i) * 3;
                        
                        ctx.fillStyle = i % 2 === 0 ? '#FF6600' : '#FFAA00';
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // í­ë°œ ì¶©ê²©íŒŒ ë§
                    ctx.strokeStyle = '#FF4500';
                    ctx.lineWidth = 5 + level;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius * 0.9, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ì¤‘ì•™ ì„¬ê´‘ (ë” ê°•ë ¬í•˜ê²Œ)
                    if (effect.life > 20) {
                        const flashSize = 40 + level * 10;
                        const flashGradient = ctx.createRadialGradient(effect.x, effect.y, 0, effect.x, effect.y, flashSize);
                        flashGradient.addColorStop(0, 'rgba(255,255,255,1)');
                        flashGradient.addColorStop(0.3, 'rgba(255,255,200,0.9)');
                        flashGradient.addColorStop(0.6, 'rgba(255,200,100,0.6)');
                        flashGradient.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = flashGradient;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, flashSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // ì—°ê¸° íš¨ê³¼
                    if (effect.life < 25) {
                        ctx.globalAlpha = alpha * 0.5;
                        for (let i = 0; i < 5; i++) {
                            const smokeX = effect.x + (Math.random() - 0.5) * effect.radius;
                            const smokeY = effect.y - (35 - effect.life) * 2 + (Math.random() - 0.5) * 20;
                            const smokeSize = 15 + Math.random() * 20;
                            
                            ctx.fillStyle = `rgba(100,100,100,${0.3 * alpha})`;
                            ctx.beginPath();
                            ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                ctx.restore();
            });
            
            // ===== ë² ê¸°/ë§ì¹˜ ì´í™íŠ¸ ë Œë”ë§ =====
            this.slashes.forEach(s => {
                if (!this.isInView(s.x, s.y, 100)) return;
                
                ctx.save();
                ctx.globalAlpha = s.opacity;
                ctx.translate(s.x, s.y);
                ctx.rotate(s.angle);
                
                if (s.isHammer) {
                    // ë§ì¹˜ íƒ€ê²© íš¨ê³¼
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 70);
                    gradient.addColorStop(0, 'rgba(255,215,0,0.8)');
                    gradient.addColorStop(0.5, 'rgba(255,165,0,0.4)');
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 70, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ì¶©ê²©íŒŒ ë§
                    ctx.strokeStyle = 'rgba(255,215,0,0.9)';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.arc(0, 0, 50 * (1 - s.life / 20), 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 40 * (1 - s.life / 20), 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // ì „ì‚¬ ë² ê¸° íš¨ê³¼
                    const gradient = ctx.createLinearGradient(-60, 0, 60, 0);
                    gradient.addColorStop(0, 'transparent');
                    gradient.addColorStop(0.5, s.color);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.arc(0, 0, 60, -Math.PI/3, Math.PI/3);
                    ctx.stroke();
                    
                    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 60, -Math.PI/4, Math.PI/4);
                    ctx.stroke();
                }
                
                ctx.restore();
            });
            
            this.enemies.forEach(e => {
                if (this.isInView(e.x, e.y, 100)) e.draw();
            });
            
            this.projectiles.forEach(p => {
                if (this.isInView(p.x, p.y, 50)) p.draw();
            });
            
            // ===== ì  íˆ¬ì‚¬ì²´ ë Œë”ë§ =====
            (this.enemyProjectiles || []).forEach(ep => {
                if (this.isInView(ep.x, ep.y, 50)) {
                    ctx.save();
                    
                    if (ep.isBossProjectile) {
                        // ë³´ìŠ¤ í™”ì—¼íƒ„
                        const size = ep.size || 12;
                        ctx.translate(ep.x, ep.y);
                        
                        // ì™¸ê³½ í™”ì—¼
                        ctx.fillStyle = '#ff4400';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ë‚´ë¶€ í•µì‹¬
                        ctx.fillStyle = '#ffaa00';
                        ctx.beginPath();
                        ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ì¤‘ì‹¬ ë°ì€ ë¶€ë¶„
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.shadowBlur = 0;
                    } else if (ep.isRock) {
                        // ê±°ì¸ì˜ ëŒ
                        const rockSize = ep.size || 18;
                        ctx.translate(ep.x, ep.y);
                        ctx.rotate(Date.now() / 200);  // íšŒì „ íš¨ê³¼
                        
                        // ëŒ ë³¸ì²´ (ë‹¤ê°í˜•)
                        ctx.fillStyle = '#666';
                        ctx.beginPath();
                        ctx.moveTo(-rockSize * 0.8, -rockSize * 0.3);
                        ctx.lineTo(-rockSize * 0.3, -rockSize * 0.9);
                        ctx.lineTo(rockSize * 0.5, -rockSize * 0.7);
                        ctx.lineTo(rockSize * 0.9, 0);
                        ctx.lineTo(rockSize * 0.6, rockSize * 0.8);
                        ctx.lineTo(-rockSize * 0.4, rockSize * 0.6);
                        ctx.lineTo(-rockSize * 0.9, rockSize * 0.1);
                        ctx.closePath();
                        ctx.fill();
                        
                        // ëŒ í•˜ì´ë¼ì´íŠ¸
                        ctx.fillStyle = '#888';
                        ctx.beginPath();
                        ctx.moveTo(-rockSize * 0.3, -rockSize * 0.5);
                        ctx.lineTo(rockSize * 0.2, -rockSize * 0.4);
                        ctx.lineTo(rockSize * 0.3, 0);
                        ctx.lineTo(-rockSize * 0.2, rockSize * 0.1);
                        ctx.closePath();
                        ctx.fill();
                        
                        // ê·¸ë¦¼ì íš¨ê³¼
                        ctx.fillStyle = '#444';
                        ctx.beginPath();
                        ctx.arc(rockSize * 0.3, rockSize * 0.3, rockSize * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // ì•…ë§ˆì˜ ë¶ˆê½ƒ
                        ctx.fillStyle = '#f00';
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = '#f00';
                        ctx.beginPath();
                        ctx.arc(ep.x, ep.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#ff0';
                        ctx.beginPath();
                        ctx.arc(ep.x, ep.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    
                    ctx.restore();
                }
            });
            
            // ===== í« íˆ¬ì‚¬ì²´ ë Œë”ë§ =====
            this.petProjectiles.forEach(p => {
                if (this.isInView(p.x, p.y, 50)) p.draw();
            });
            
            this.particles.forEach(p => {
                if (this.isInView(p.x, p.y, 50)) {
                    ctx.save();
                    ctx.globalAlpha = p.life / 40;
                    ctx.fillStyle = p.color;
                    ctx.font = `${24 * p.scale}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(p.text, p.x, p.y);
                    ctx.restore();
                }
            });
            
            this.player.draw();
            
            // ===== í« ë Œë”ë§ =====
            this.pets.forEach(pet => {
                if (this.isInView(pet.x, pet.y, 100)) pet.draw();
            });
            
            ctx.restore();
            
            this.updateUI();
            this.drawMinimap();
        }
        
        requestAnimationFrame((timestamp) => this.loop(timestamp));
    }
};

// ===== í•˜ë“œëª¨ë“œ í† ê¸€ í•¨ìˆ˜ =====
G.toggleHardMode = function() {
    hardMode = !hardMode;
    const titleEl = document.querySelector('#mainScreen .title');
    if (hardMode) {
        titleEl.innerHTML = 'ğŸ”¥ ìˆ˜í•™ íƒí—˜ê°€ ğŸ”¥';
        titleEl.style.color = '#f44';
        SoundManager.play('square', 880, 0.1);
        setTimeout(() => SoundManager.play('square', 1100, 0.1), 100);
    } else {
        titleEl.innerHTML = 'ğŸ§® ìˆ˜í•™ íƒí—˜ê°€ ğŸ§®';
        titleEl.style.color = '';
        SoundManager.play('square', 440, 0.1);
    }
};

// ===== ì „ì²´í™”ë©´ í† ê¸€ í•¨ìˆ˜ ì¶”ê°€ =====
G.toggleFullscreen = function() {
    if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        // ì „ì²´í™”ë©´ ì§„ì…
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
        } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
        }
        document.getElementById('fullscreenBtn').textContent = 'â›¶';
    } else {
        // ì „ì²´í™”ë©´ ì¢…ë£Œ
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
        document.getElementById('fullscreenBtn').textContent = 'â›¶';
    }
};

// ===== ì‚¬ìš´ë“œ í† ê¸€ í•¨ìˆ˜ =====
G.toggleSound = function() {
    const enabled = SoundManager.toggle();
    const btn = document.getElementById('soundBtn');
    btn.textContent = enabled ? 'ğŸ”Š' : 'ğŸ”‡';
    
    if (enabled) {
        SoundManager.startMusic();
    }
};

// ===== í« í´ë˜ìŠ¤ =====
class Pet {
    constructor(x, y, type, level) {
        this.x = x;
        this.y = y;
        this.type = type;  // 'angel' or 'demon'
        this.level = level;
        this.angle = Math.random() * Math.PI * 2;  // ì•…ë§ˆ í«ìš© íšŒì „ ê°ë„
        this.lastAttack = 0;
        this.orbitRadius = 60;  // ì•…ë§ˆ í« ê¶¤ë„ ë°˜ì§€ë¦„
        this.floatOffset = 0;
        this.updateStats();
    }
    
    updateStats() {
        if (this.type === 'angel') {
            this.damage = 8 + this.level * 4;  // ë ˆë²¨ë‹¹ ê³µê²©ë ¥ +4
            this.pierce = Math.floor(this.level / 2);  // ë ˆë²¨ 2ë§ˆë‹¤ ê´€í†µ +1
            this.attackSpeed = 1200;  // 1.2ì´ˆë§ˆë‹¤ ê³µê²©
            this.range = 250;
        } else {  // demon
            this.damage = 12 + this.level * 5;  // ë ˆë²¨ë‹¹ ê³µê²©ë ¥ +5
            this.attackSpeed = Math.max(400, 1000 - this.level * 100);  // ë ˆë²¨ë‹¹ ê³µê²© ë¹ˆë„ ì¦ê°€
            this.range = 50;  // ê·¼ì ‘
        }
    }
    
    update() {
        const player = G.player;
        if (!player) return;
        
        this.floatOffset = Math.sin(Date.now() / 300) * 5;
        
        if (this.type === 'angel') {
            // ì²œì‚¬: í”Œë ˆì´ì–´ ë’¤ë¥¼ ë”°ë¼ë‹¤ë‹˜
            const targetX = player.x - 40;
            const targetY = player.y - 30 + this.floatOffset;
            this.x += (targetX - this.x) * 0.1;
            this.y += (targetY - this.y) * 0.1;
            
            // ì›ê±°ë¦¬ ê³µê²©
            const now = Date.now();
            if (now - this.lastAttack > this.attackSpeed) {
                const nearest = this.getNearestEnemy();
                if (nearest && Math.hypot(nearest.x - this.x, nearest.y - this.y) < this.range) {
                    this.shootAngel(nearest);
                    this.lastAttack = now;
                }
            }
        } else {  // demon
            // ì•…ë§ˆ: í”Œë ˆì´ì–´ ê·¼ì²˜ë¥¼ ì™”ë‹¤ê°”ë‹¤ í•˜ë©° ê³µê²©
            // ë ˆë²¨ì— ë”°ë¼ ê±°ë¦¬ ì¡°ì • (í™”ë©´ ì•ˆì— ìœ ì§€)
            const baseDistance = 60;
            const levelBonus = Math.min(this.level * 15, 120);  // ìµœëŒ€ 120 ì¶”ê°€
            const maxDistance = Math.min(baseDistance + levelBonus, 200);  // ìµœëŒ€ 200 (í™”ë©´ ì•ˆ)
            
            // ì™”ë‹¤ê°”ë‹¤ ì›€ì§ì„ (ì‚¬ì¸/ì½”ì‚¬ì¸ ì¡°í•©ìœ¼ë¡œ 8ì í˜•íƒœ)
            const time = Date.now() / 500;
            const moveX = Math.sin(time) * maxDistance * 0.7;
            const moveY = Math.sin(time * 1.5) * maxDistance * 0.4;
            
            const targetX = player.x + moveX;
            const targetY = player.y + moveY + this.floatOffset;
            
            // ë¶€ë“œëŸ¬ìš´ ì´ë™
            this.x += (targetX - this.x) * 0.08;
            this.y += (targetY - this.y) * 0.08;
            
            // ê·¼ì ‘ ê³µê²©
            const now = Date.now();
            if (now - this.lastAttack > this.attackSpeed) {
                const nearest = this.getNearestEnemy();
                if (nearest && Math.hypot(nearest.x - this.x, nearest.y - this.y) < this.range + nearest.size) {
                    this.attackDemon(nearest);
                    this.lastAttack = now;
                }
            }
        }
    }
    
    getNearestEnemy() {
        let nearest = null;
        let minDist = Infinity;
        
        G.enemies.forEach(e => {
            const dist = Math.hypot(e.x - this.x, e.y - this.y);
            if (dist < minDist) {
                minDist = dist;
                nearest = e;
            }
        });
        
        return nearest;
    }
    
    shootAngel(target) {
        const angle = Math.atan2(target.y - this.y, target.x - this.x);
        G.petProjectiles.push(new PetProjectile(this.x, this.y, angle, this, 'angel'));
    }
    
    attackDemon(target) {
        // ê·¼ì ‘ ê³µê²© - ë°ë¯¸ì§€ ì£¼ê¸°
        target.hp -= this.damage;
        G.textParticle(target.x, target.y, `-${this.damage}`, '#f0f', 0.8);
        
        // ê³µê²© ì´í™íŠ¸
        G.slashes.push({
            x: this.x,
            y: this.y,
            angle: Math.atan2(target.y - this.y, target.x - this.x),
            life: 10,
            opacity: 1,
            color: '#f0f'
        });
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.type === 'angel') {
            // ì²œì‚¬ ê·¸ë¦¬ê¸° - ì‘ì€ ë™ê·¸ë€ ë¹›ì— ë‚ ê°œ
            const glow = Math.sin(Date.now() / 200) * 0.2 + 0.8;
            
            // í›„ê´‘ (ì‘ê²Œ)
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff0';
            ctx.fillStyle = `rgba(255,255,200,${glow * 0.4})`;
            ctx.beginPath();
            ctx.arc(0, 0, 18, 0, Math.PI * 2);
            ctx.fill();
            
            // ë‚ ê°œ (ì‘ì€ íƒ€ì›í˜•)
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#fff';
            // ì™¼ìª½ ë‚ ê°œ
            ctx.beginPath();
            ctx.ellipse(-12, 0, 8, 5, -0.4, 0, Math.PI * 2);
            ctx.fill();
            // ì˜¤ë¥¸ìª½ ë‚ ê°œ
            ctx.beginPath();
            ctx.ellipse(12, 0, 8, 5, 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // ì¤‘ì•™ ë¹›ë‚˜ëŠ” êµ¬ì²´ (ëª¸í†µ)
            const bodyGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 10);
            bodyGradient.addColorStop(0, 'rgba(255,255,255,1)');
            bodyGradient.addColorStop(0.5, 'rgba(255,255,200,0.9)');
            bodyGradient.addColorStop(1, 'rgba(255,220,100,0.6)');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // ì‘ì€ ë§ (halo)
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(0, -14, 7, 2.5, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            
            // ë ˆë²¨ í‘œì‹œ
            ctx.fillStyle = '#fff';
            ctx.font = '9px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Lv.${this.level}`, 0, 22);
        } else {
            // ì•…ë§ˆ ê·¸ë¦¬ê¸° (í¬ê¸° ì¶•ì†Œ)
            const pulse = Math.sin(Date.now() / 150) * 0.2 + 0.8;
            
            // ì–´ë‘ìš´ ì•„ìš°ë¼ (ì‘ê²Œ)
            ctx.shadowBlur = 12;
            ctx.shadowColor = '#800';
            ctx.fillStyle = `rgba(100,0,0,${pulse * 0.3})`;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // ëª¸ (ì‘ê²Œ)
            ctx.fillStyle = '#800';
            ctx.beginPath();
            ctx.arc(0, 3, 9, 0, Math.PI * 2);
            ctx.fill();
            
            // ë¨¸ë¦¬ (ì‘ê²Œ)
            ctx.fillStyle = '#a00';
            ctx.beginPath();
            ctx.arc(0, -5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // ë¿” (ì‘ê²Œ)
            ctx.fillStyle = '#400';
            ctx.beginPath();
            ctx.moveTo(-6, -9);
            ctx.lineTo(-9, -18);
            ctx.lineTo(-3, -10);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(6, -9);
            ctx.lineTo(9, -18);
            ctx.lineTo(3, -10);
            ctx.closePath();
            ctx.fill();
            
            // ëˆˆ
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            ctx.arc(-3, -5, 1.5, 0, Math.PI * 2);
            ctx.arc(3, -5, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // ê¼¬ë¦¬ (ì‘ê²Œ)
            ctx.strokeStyle = '#800';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 11);
            ctx.quadraticCurveTo(10, 14, 7, 18);
            ctx.stroke();
            
            // ê¼¬ë¦¬ ë í™”ì‚´í‘œ (ì‘ê²Œ)
            ctx.fillStyle = '#400';
            ctx.beginPath();
            ctx.moveTo(7, 18);
            ctx.lineTo(11, 16);
            ctx.lineTo(9, 21);
            ctx.closePath();
            ctx.fill();
            
            // ë ˆë²¨ í‘œì‹œ
            ctx.fillStyle = '#ff0';
            ctx.font = '9px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Lv.${this.level}`, 0, 28);
        }
        
        ctx.restore();
    }
}

// ===== í« íˆ¬ì‚¬ì²´ í´ë˜ìŠ¤ =====
class PetProjectile {
    constructor(x, y, angle, pet, type) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.vx = Math.cos(angle) * 8;
        this.vy = Math.sin(angle) * 8;
        this.pet = pet;
        this.type = type;
        this.damage = pet.damage;
        this.pierce = pet.pierce;
        this.hit = new Set();
    }
    
    update() {
        this.x += this.vx * gameSpeedMultiplier;
        this.y += this.vy * gameSpeedMultiplier;
        
        if (Math.abs(this.x - G.player.x) > 400 || Math.abs(this.y - G.player.y) > 400) {
            return false;
        }
        
        // ì¥ì• ë¬¼ ì¶©ëŒ ê²€ì‚¬
        for (let obs of G.obstacles) {
            const obstDist = Math.hypot(this.x - obs.x, this.y - obs.y);
            if (obstDist < obs.size) {
                return false;
            }
        }
        
        for (let e of G.enemies) {
            if (!this.hit.has(e) && Math.hypot(e.x - this.x, e.y - this.y) < e.size + 8) {
                e.hp -= this.damage;
                G.textParticle(e.x, e.y, `-${this.damage}`, '#ff0', 0.8);
                this.hit.add(e);
                if (this.pierce <= 0) return false;
                this.pierce--;
            }
        }
        
        return true;
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // ì²œì‚¬ íˆ¬ì‚¬ì²´ (ë¹›ë‚˜ëŠ” í™”ì‚´)
        ctx.fillStyle = '#ffd700';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff0';
        
        // í™”ì‚´ ëª¨ì–‘
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-5, -4);
        ctx.lineTo(-5, 4);
        ctx.closePath();
        ctx.fill();
        
        // ë¹›ë‚˜ëŠ” ê¼¬ë¦¬
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(-5, 0);
        ctx.lineTo(-15, -2);
        ctx.lineTo(-15, 2);
        ctx.closePath();
        ctx.fill();
        
        ctx.shadowBlur = 0;
        ctx.restore();
    }
}

class Player {
    constructor(x, y, design) {
        this.x = x;
        this.y = y;
        this.design = design;
        this.hp = 100;
        this.maxHp = 100;
        this.level = 1;
        this.exp = 0;
        this.expNext = 100;
        this.damage = 20;
        this.speed = hardMode ? 3.3 : 3;  // í•˜ë“œëª¨ë“œ: 1.1ë°°
        this.range = 120;
        this.atkSpeed = 500;
        this.pierce = 0;
        this.multishot = 0;
        this.lastAtk = 0;
        this.walkAnim = 0;
        
        this.shield = false;
        this.shieldHp = 0;
        this.regen = 0;
        this.crit = 0;
        
        this.spinBlade = false;
        this.spinAngle = 0;
        this.spinDmgMultiplier = 0;
        
        this.itemLevels = {};
        this.skillLevels = {};
        this.poison = false;
        this.freeze = false;
        this.explode = false;
        this.lightning = 0;
        this.meteorChance = 0;
        this.poisonDmg = 0;
        this.meteorDmg = 0;
        this.spinBladeLastHit = {};  // íšŒì „ ê²€ ì¿¨ë‹¤ìš´ ì¶”ì 
        this.lastMeteorTime = 0;  // ìš´ì„ ì¿¨íƒ€ì„ ì¶”ì 
        this.lastLightningTime = 0;  // ë²ˆê°œ ì¿¨íƒ€ì„ ì¶”ì 
        this.lastDamageTime = 0;  // í”¼ê²© ë¬´ì  ì‹œê°„ ì¶”ì 
        
        // ===== ìºë¦­í„°ë³„ ìŠ¤íƒ¯ ì¡°ì • =====
        
        // ì „ì‚¬: ê·¼ì ‘ ê³µê²©ì´ë¯€ë¡œ ì²´ë ¥ ë†’ìŒ (ê¸°ë³¸ 100ì˜ 1.8ë°°)
        if (design.type.includes('warrior')) {
            this.maxHp = 180;
            this.hp = 180;
        }
        
        // ë°œí‚¤ë¦¬: ë§ì¹˜ ê·¼ì ‘ ê³µê²© (ë†’ì€ ë°ë¯¸ì§€, ëŠë¦° ì†ë„, ì²´ë ¥ ì¦ê°€)
        if (design.type.includes('valkyrie')) {
            this.maxHp = 120;
            this.hp = 120;
            this.damage = 30;        // ë†’ì€ ë°ë¯¸ì§€
            this.atkSpeed = 800;     // ëŠë¦° ê³µê²© ì†ë„
            this.range = 100;        // ì§§ì€ ê³µê²© ë²”ìœ„
        }
        
        // ë²•ì‚¬: ì´ˆê¸° ìŠ¤íƒ¯ ì•½ê°„ ì¡°ì • (ê³µê²©ë ¥ ê°ì†Œ)
        if (design.type.includes('mage')) {
            this.damage = 16;
            this.atkSpeed = 450;
        }
    }
    
    update() {
        // ===== ì´ë™ ëª©í‘œ ì„¤ì • =====
        let targetX = this.x;
        let targetY = this.y;
        
        // ë§ˆìš°ìŠ¤ í´ë¦­ ë˜ëŠ” í„°ì¹˜ ì…ë ¥ ì²˜ë¦¬
        if (G.mouse.pressed) {
            targetX = G.camera.x + G.mouse.x;
            targetY = G.camera.y + G.mouse.y;
        } else if (G.touch.active) {
            targetX = G.camera.x + G.touch.x;
            targetY = G.camera.y + G.touch.y;
        }
        
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist > 20) {
            const oldX = this.x;
            const oldY = this.y;
            
            // gameSpeedMultiplier ì ìš©í•˜ì—¬ í”„ë ˆì„ ì†ë„ì™€ ë¬´ê´€í•˜ê²Œ ì¼ì •í•œ ì´ë™
            const moveSpeed = this.speed * gameSpeedMultiplier;
            this.x += (dx / dist) * moveSpeed;
            this.y += (dy / dist) * moveSpeed;
            this.walkAnim += 0.2 * gameSpeedMultiplier;
            
            // ì¥ì• ë¬¼ ì¶©ëŒ ê²€ì‚¬
            let collided = false;
            for (let obs of G.obstacles) {
                const obstDist = Math.hypot(this.x - obs.x, this.y - obs.y);
                if (obstDist < obs.size + 25) {
                    collided = true;
                    break;
                }
            }
            
            // ì¶©ëŒ ì‹œ ì´ì „ ìœ„ì¹˜ë¡œ ë³µê·€
            if (collided) {
                this.x = oldX;
                this.y = oldY;
            }
        }
        
        this.x = Math.max(50, Math.min(MAP_WIDTH - 50, this.x));
        this.y = Math.max(50, Math.min(MAP_HEIGHT - 50, this.y));
        
        // ===== íšŒì „ ê²€ ì•„ì´í…œ íš¨ê³¼ =====
        if (this.spinBlade) {
            this.spinAngle += 0.15 * gameSpeedMultiplier;
            
            const now = Date.now();
            G.enemies.forEach(e => {
                for (let i = 0; i < 3; i++) {
                    const a = this.spinAngle + i * Math.PI * 2 / 3;
                    const bladeX = this.x + Math.cos(a) * 80;
                    const bladeY = this.y + Math.sin(a) * 80;
                    
                    if (Math.hypot(e.x - bladeX, e.y - bladeY) < e.size + 20) {
                        // ê° ì ë§ˆë‹¤ 0.2ì´ˆ ì¿¨ë‹¤ìš´ ì ìš©
                        const lastHit = this.spinBladeLastHit[e] || 0;
                        if (now - lastHit > 200) {
                            // í”Œë ˆì´ì–´ ë°ë¯¸ì§€ * ë°°ìœ¨ë¡œ íšŒì „ê²€ ë°ë¯¸ì§€ ê³„ì‚°
                            const spinDamage = this.damage * (this.spinDmgMultiplier || 0.25);
                            this.dealDamage(e, spinDamage);
                            this.spinBladeLastHit[e] = now;
                        }
                    }
                }
            });
        }
        
        const now = Date.now();
        if (now - this.lastAtk > this.atkSpeed) {
            const nearest = this.getNearestEnemy();
            if (nearest && Math.hypot(nearest.x - this.x, nearest.y - this.y) < this.range + nearest.size) {
                this.attack(nearest);
                this.lastAtk = now;
            }
        }
        
        if (this.regen > 0) {
            this.hp = Math.min(this.maxHp, this.hp + this.regen * 0.1);
        }
    }
    
    getNearestEnemy() {
        let nearest = null;
        let minDist = Infinity;
        
        G.enemies.forEach(e => {
            const dist = Math.hypot(e.x - this.x, e.y - this.y);
            if (dist < minDist) {
                minDist = dist;
                nearest = e;
            }
        });
        
        return nearest;
    }
    
    attack(target) {
        // ===== ì „ì‚¬: ê·¼ì ‘ ë² ê¸° ê³µê²© =====
        if (this.design.type.includes('warrior')) {
            SoundManager.attack('warrior');
            this.dealDamage(target, this.damage);
            
            // ì „ì‚¬ ë² ê¸° ì´í™íŠ¸
            const angle = Math.atan2(target.y - this.y, target.x - this.x);
            G.slashes.push({
                x: this.x,
                y: this.y,
                angle: angle,
                life: 15,
                opacity: 1,
                color: '#0ff'
            });
        } 
        // ===== ë°œí‚¤ë¦¬: ë§ì¹˜ ê·¼ì ‘ ê³µê²© =====
        else if (this.design.type.includes('valkyrie')) {
            SoundManager.attack('valkyrie');
            this.dealDamage(target, this.damage);
            
            // ë§ì¹˜ íƒ€ê²© ì´í™íŠ¸
            const angle = Math.atan2(target.y - this.y, target.x - this.x);
            
            // ë§ì¹˜ ìŠ¤ìœ™ íš¨ê³¼
            G.slashes.push({
                x: this.x,
                y: this.y,
                angle: angle,
                life: 20,
                opacity: 1,
                color: '#ffd700',  // ê¸ˆìƒ‰ ë§ì¹˜ íš¨ê³¼
                isHammer: true     // ë§ì¹˜ íš¨ê³¼ í”Œë˜ê·¸
            });
            
            // íƒ€ê²© ì§€ì ì— ì¶©ê²©íŒŒ íš¨ê³¼
            G.effects.push({
                type: 'hammerImpact',
                x: target.x,
                y: target.y,
                radius: 0,
                maxRadius: 40,
                life: 15
            });
            
            // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼
            G.screenShake = 3;
        } 
        // ===== ê¶ìˆ˜/ë²•ì‚¬: ì›ê±°ë¦¬ íˆ¬ì‚¬ì²´ ê³µê²© =====
        else {
            const angle = Math.atan2(target.y - this.y, target.x - this.x);
            const isRanger = this.design.type.includes('ranger');
            
            // ê³µê²© ì‚¬ìš´ë“œ
            SoundManager.attack(isRanger ? 'archer' : 'mage');
            
            // íˆ¬ì‚¬ì²´ ë°œì‚¬ (ë©€í‹°ìƒ· í¬í•¨)
            // ë©€í‹°ìƒ· ì—†ìœ¼ë©´ 1ë°œ, ë©€í‹°ìƒ· nê°œë©´ n+1ë°œ (ë¶€ì±„ê¼´ë¡œ ë°œì‚¬)
            const totalShots = 1 + this.multishot;
            const spreadAngle = 0.15; // ê° íˆ¬ì‚¬ì²´ ê°„ ê°ë„
            const startAngle = angle - (totalShots - 1) * spreadAngle / 2;
            
            for (let i = 0; i < totalShots; i++) {
                const shotAngle = startAngle + i * spreadAngle;
                G.projectiles.push(new Projectile(this.x, this.y, shotAngle, this, isRanger));
            }
        }
    }
    
    dealDamage(enemy, dmg) {
        // ê²Œì„ì´ ì¼ì‹œì •ì§€ ì¤‘ì´ë©´ ë°ë¯¸ì§€ë¥¼ ì£¼ì§€ ì•ŠìŒ (ë³´ìŠ¤ ìŠ¤í° ì¤‘ ë“±)
        if (G.paused) {
            return;
        }
        
        // ===== ë°ë¯¸ì§€ ê³„ì‚° =====
        let finalDmg = dmg;
        
        // ì¹˜ëª…íƒ€ ê³„ì‚°
        if (Math.random() < this.crit) {
            finalDmg *= 2;
            G.textParticle(enemy.x, enemy.y - 30, 'ì¹˜ëª…íƒ€!', '#ff0', 1);
        }
        
        // ì ì—ê²Œ ë°ë¯¸ì§€ ì ìš©
        enemy.hp -= finalDmg;
        
        // í”¼ê²© ì‚¬ìš´ë“œ (ë„ˆë¬´ ìì£¼ ì¬ìƒë˜ì§€ ì•Šë„ë¡ 30% í™•ë¥ )
        if (Math.random() < 0.3) {
            SoundManager.hit();
        }
        
        // ê°„ê²°í•œ ë°ë¯¸ì§€ í‘œì‹œ (ì •ìˆ˜ë¡œ ë°˜ì˜¬ë¦¼)
        const displayDmg = Math.round(finalDmg);
        G.textParticle(enemy.x, enemy.y, `-${displayDmg}`, '#f00', 0.8);
        
        // ===== ìƒíƒœ ì´ìƒ íš¨ê³¼ ì ìš© =====
        
        // ë… êµ¬ë¦„ íš¨ê³¼ (í™•ë¥ : 50%)
        if (this.poison && Math.random() < 0.5) {
            // ë… êµ¬ë¦„ ìƒì„± (2ì´ˆê°„ ì§€ì†)
            G.effects.push({
                type: 'poisoncloud',
                x: enemy.x,
                y: enemy.y,
                radius: 50,
                life: 120, // 2ì´ˆ (60fps ê¸°ì¤€)
                damage: this.poisonDmg
            });
        }
        
        // ì–¼ìŒ íš¨ê³¼ (ì´ë™ì†ë„ ê°ì†Œ, í™•ë¥ : 40% - ì¦ê°€)
        if (this.freeze && Math.random() < 0.4) {
            enemy.frozen = true;
            enemy.frozenSpeed = enemy.speed;
            enemy.speed *= 0.3;
            setTimeout(() => {
                if (enemy.frozen) {
                    enemy.frozen = false;
                    enemy.speed = enemy.frozenSpeed;
                }
            }, 1500);
        }
        
        // ===== ì•„ì´í…œ íš¨ê³¼ - ì  íƒ€ê²©ì‹œ ë°œë™ (ì›ê±°ë¦¬ íš¨ê³¼ëŠ” íì— ì¶”ê°€) =====
        
        // ë²ˆê°œ íš¨ê³¼ (ë ˆë²¨ë‹¹ ì •í™•íˆ 1ê°œì”© ì¶”ê°€, ìµœëŒ€ 3ê°œ)
        // í™•ë¥ : 30% (ë” ìì£¼ ë°œë™ë˜ë„ë¡ ì¦ê°€)
        // ì¿¨íƒ€ì„: 1ì´ˆ
        if (this.itemLevels.lightning && Math.random() < 0.3) {
            const now = Date.now();
            if (!this.lastLightningTime) this.lastLightningTime = 0;
            
            if (now - this.lastLightningTime > 1000) {  // 1ì´ˆ ì¿¨íƒ€ì„
                this.lastLightningTime = now;
                const level = this.itemLevels.lightning;
                const count = Math.min(level, 3);  // ìµœëŒ€ 3ì¤„ê¸°
                
                // ì´ë¯¸ ë²¼ë½ ë§ì€ ì  ì¶”ì 
                const lightningTargets = new Set();
                lightningTargets.add(enemy);  // í˜„ì¬ íƒ€ê²©ë‹¹í•œ ì ì€ ì œì™¸
                
                for (let i = 0; i < count; i++) {
                    // ë‹¤ë¥¸ ì  ì¤‘ì—ì„œ ë²¼ë½ ëŒ€ìƒ ì„ íƒ
                    let targetEnemy = null;
                    for (let e of G.enemies) {
                        if (!lightningTargets.has(e) && Math.hypot(e.x - enemy.x, e.y - enemy.y) < 200) {
                            targetEnemy = e;
                            lightningTargets.add(e);
                            break;
                        }
                    }
                    
                    if (targetEnemy) {
                        const ex = targetEnemy.x;
                        const ey = targetEnemy.y;
                        const lv = level;
                        G.queueRangedEffect(() => {
                            G.createLightning(ex, ey, lv);
                        });
                    } else if (i === 0) {
                        // ì²« ë²ˆì§¸ ë²¼ë½ì€ ì›ë˜ ì  ìœ„ì¹˜ ê·¼ì²˜ì—
                        const offset = (Math.random() - 0.5) * 60;
                        const ex = enemy.x + offset;
                        const ey = enemy.y;
                        const lv = level;
                        G.queueRangedEffect(() => {
                            G.createLightning(ex, ey, lv);
                        });
                    }
                }
            }
        }
        
        // ìš´ì„ íš¨ê³¼ (ë ˆë²¨ê³¼ ê´€ê³„ì—†ì´ 1ê°œë§Œ, 1.5ì´ˆ ì¿¨íƒ€ì„)
        const now = Date.now();
        if (this.meteorChance && Math.random() < this.meteorChance && now - this.lastMeteorTime > 1500) {
            this.lastMeteorTime = now;
            const level = this.itemLevels.meteor || 1;
            const ex = enemy.x;
            const ey = enemy.y;
            G.queueRangedEffect(() => {
                G.createMeteor(ex, ey, level);
            });
        }
        
        // ì–¼ìŒ ìŠ¤íŒŒì´í¬ íš¨ê³¼ (ë ˆë²¨ë‹¹ ì •í™•íˆ 1ê°œì”© ì¶”ê°€)
        if (this.freeze && this.itemLevels.freeze && Math.random() < 0.25) {
            const level = this.itemLevels.freeze;
            const count = level;
            
            for (let i = 0; i < count; i++) {
                const offset = (Math.random() - 0.5) * 100;
                const ex = enemy.x + offset;
                const ey = enemy.y;
                const lv = level;
                G.queueRangedEffect(() => {
                    G.createIceSpike(ex, ey, lv);
                });
            }
        }
        
        // ===== ì  ì²˜ì¹˜ ì‹œ =====
        if (enemy.hp <= 0) {
            // íšŒì „ ê²€ ì¿¨ë‹¤ìš´ ë§µì—ì„œ ì œê±° (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
            delete this.spinBladeLastHit[enemy];
            
            // ì²˜ì¹˜ ì‚¬ìš´ë“œ (ë³´ìŠ¤ëŠ” íŠ¹ë³„ ì‚¬ìš´ë“œ)
            if (enemy.isBoss) {
                SoundManager.bossKill();
            } else {
                SoundManager.kill();
            }
            
            G.score += enemy.score;
            this.gainExp(enemy.exp);
            
            // ë³´ë¬¼ìƒì ìµœëŒ€ 3ê°œ ì œí•œ
            const currentChests = G.items.filter(item => item.type === 'chest').length;
            
            // ë³´ë¬¼ìƒì ë˜ëŠ” ê²½í—˜ì¹˜ ì•„ì´í…œ ë“œë¡­
            // ë³´ë¬¼ìƒì: 10% í™•ë¥  (ë°˜í† ë§‰)
            if (Math.random() < 0.1 && currentChests < 3) {
                G.items.push({x: enemy.x, y: enemy.y, type: 'chest'});
            } else if (Math.random() < 0.3) {
                G.items.push({x: enemy.x, y: enemy.y, type: 'exp', value: enemy.exp});
            }
            
            // ë ˆì´ì € ì•„ì´í…œ íš¨ê³¼ (í”Œë ˆì´ì–´ì—ì„œ ë°œì‚¬)
            if (this.explode) {
                // ë¹” ë°œì‚¬ ê°ë„ (ì  ë°©í–¥)
                const beamAngle = Math.atan2(enemy.y - this.y, enemy.x - this.x);
                const beamLength = 400;
                const beamEndX = this.x + Math.cos(beamAngle) * beamLength;
                const beamEndY = this.y + Math.sin(beamAngle) * beamLength;
                
                G.effects.push({
                    type: 'beam',
                    startX: this.x,
                    startY: this.y,
                    x: this.x,
                    y: this.y,
                    endX: beamEndX,
                    endY: beamEndY,
                    angle: beamAngle,
                    length: beamLength,
                    life: 20,
                    width: 0
                });
                
                // ë¹” ê²½ë¡œìƒì˜ ëª¨ë“  ì ì—ê²Œ ë°ë¯¸ì§€
                setTimeout(() => {
                    // ì¼ì‹œì •ì§€ ì¤‘ì´ë©´ ë°ë¯¸ì§€ë¥¼ ì£¼ì§€ ì•ŠìŒ
                    if (G.paused) return;
                    
                    const playerX = G.player.x;
                    const playerY = G.player.y;
                    
                    G.enemies.forEach(e => {
                        // ì ê³¼ ì„ ë¶„ ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
                        const dx = beamEndX - playerX;
                        const dy = beamEndY - playerY;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const dotProduct = ((e.x - playerX) * dx + (e.y - playerY) * dy) / (length * length);
                        
                        if (dotProduct >= 0 && dotProduct <= 1) {
                            const closestX = playerX + dotProduct * dx;
                            const closestY = playerY + dotProduct * dy;
                            const distance = Math.hypot(e.x - closestX, e.y - closestY);
                            
                            if (distance < 15) { // ë¹” í­ 15 (ì ˆë°˜ìœ¼ë¡œ ì¶•ì†Œ)
                                this.dealDamage(e, this.damage * 0.4);
                            }
                        }
                    });
                }, 50);
            }
        }
    }
    
    takeDamage(dmg) {
        // ===== ë°ë¯¸ì§€ ë°›ê¸° =====
        
        // ìœ íš¨í•˜ì§€ ì•Šì€ ë°ë¯¸ì§€ ë¬´ì‹œ
        if (!dmg || isNaN(dmg) || dmg <= 0) return;
        
        // ë¬´ì  ì‹œê°„ ì²´í¬ (í”¼ê²© í›„ 0.2ì´ˆê°„ ë¬´ì  - ì—°ì† íˆíŠ¸ ë°©ì§€ìš©)
        const now = Date.now();
        if (this.lastDamageTime && now - this.lastDamageTime < 200) {
            return; // ë¬´ì  ì‹œê°„ ì¤‘ì—ëŠ” ë°ë¯¸ì§€ ë¬´ì‹œ
        }
        this.lastDamageTime = now;
        
        // ë³´í˜¸ë§‰ì´ ìˆìœ¼ë©´ ë³´í˜¸ë§‰ì´ ë¨¼ì € ë°ë¯¸ì§€ë¥¼ ë°›ìŒ
        if (this.shield && this.shieldHp > 0) {
            this.shieldHp -= dmg;
            if (this.shieldHp < 0) {
                this.hp += this.shieldHp;
                this.shieldHp = 0;
            }
        } else {
            this.hp -= dmg;
        }
        
        // í”¼ê²© ì‚¬ìš´ë“œ
        SoundManager.playerHit();
        
        // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸ í‘œì‹œ
        G.textParticle(this.x, this.y, `-${Math.round(dmg)}`, '#f00', 1);
        
        // ===== í”¼ê²© íš¨ê³¼ =====
        G.screenShake = 9;  // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼
        
        // ì£½ìŒ ì²´í¬
        if (this.hp <= 0) {
            G.gameOver();
        }
    }
    
    gainExp(amt) {
        // ===== ê²½í—˜ì¹˜ íšë“ ë° ë ˆë²¨ì—… ì²˜ë¦¬ =====
        
        // ê²Œì„ì´ ì¼ì‹œì •ì§€ ìƒíƒœë©´ ê²½í—˜ì¹˜ íšë“ ì•ˆí•¨ (ë ˆë²¨ì—… ì¤‘ë³µ ë°©ì§€)
        if (G.paused) return;
        
        this.exp += amt;
        
        // ê²½í—˜ì¹˜ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€
        if (this.exp > this.expNext * 2) {
            this.exp = this.expNext;
        }
        
        // ë ˆë²¨ì—… ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•œ ì•ˆì „ì¥ì¹˜
        let levelUpCount = 0;
        const maxLevelUps = 1; // í•œ ë²ˆì— 1ë ˆë²¨ì”©ë§Œ (ë²„ê·¸ ë°©ì§€)
        
        // ë ˆë²¨ì—… ì¡°ê±´ ì¶©ì¡± ì‹œ ë ˆë²¨ì—…
        while (this.exp >= this.expNext && levelUpCount < maxLevelUps && !G.paused) {
            this.exp -= this.expNext;
            this.level++;
            this.expNext = 100 * Math.pow(1.2, this.level - 1);
            levelUpCount++;
            
            // ì²« ë²ˆì§¸ ë ˆë²¨ì—…ì—ë§Œ ì—…ê·¸ë ˆì´ë“œ í™”ë©´ í‘œì‹œ
            if (levelUpCount === 1) {
                G.showLevelUp();
            }
        }
        
        // ê²½í—˜ì¹˜ê°€ ì—¬ì „íˆ ë„˜ì¹˜ë©´ ë‹¤ìŒ ê²½í—˜ì¹˜ ìš”êµ¬ëŸ‰ì— ë§ì¶¤
        if (this.exp >= this.expNext) {
            this.exp = this.expNext - 1;
        }
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.shield && this.shieldHp > 0) {
            ctx.strokeStyle = `rgba(100,200,255,${0.3 + Math.sin(Date.now()/200)*0.1})`;
            ctx.lineWidth = 3;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#08f';
            ctx.beginPath();
            ctx.arc(0, 0, 45, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath();
        ctx.ellipse(0, 25, 20, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        const frame = Math.floor(this.walkAnim) % 2;
        this.design.draw(ctx, frame, 1.5);
        
        if (this.spinBlade) {
            for (let i = 0; i < 3; i++) {
                const a = this.spinAngle + i * Math.PI * 2 / 3;
                ctx.save();
                ctx.translate(Math.cos(a) * 80, Math.sin(a) * 80);
                ctx.rotate(a);
                ctx.fillStyle = '#0ff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#0ff';
                ctx.fillRect(-15, -3, 30, 6);
                ctx.fillStyle = '#fff';
                ctx.fillRect(-12, -2, 24, 4);
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }
        
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, stage, forceType = null) {
        this.x = x;
        this.y = y;
        this.stage = stage;
        this.isBoss = false;
        
        // ë³´ìŠ¤ ì²˜ì¹˜ íšŸìˆ˜ì— ë”°ë¥¸ ê°•í™” ë°°ìœ¨
        const bossBonus = G.bossCount || 0;
        const postBossMultiplier = 1 + bossBonus * 0.4;  // ë³´ìŠ¤ ì²˜ì¹˜ë§ˆë‹¤ 40% ê°•í™”
        
        const sizeMultiplier = (1 + (stage - 1) * 0.15) * (1 + bossBonus * 0.15);  // í¬ê¸°ë„ ì¦ê°€
        this.size = (20 + Math.random() * 10) * sizeMultiplier;
        
        // ëª¬ìŠ¤í„° íƒ€ì… ê²°ì • (6ì¢…ë¥˜ - ì´ˆë°˜ë¶€í„° ë‹¤ì–‘í•˜ê²Œ!)
        // type 0: ìŠ¬ë¼ì„ (ë…¹ìƒ‰, ëŠë¦¼, ì²´ë ¥ ë†’ìŒ)
        // type 1: ì•…ë§ˆ (ë¹¨ê°•, ë¹ ë¦„, ê³µê²©ë ¥ ë†’ìŒ)
        // type 2: ìœ ë ¹ (ë³´ë¼, íˆ¬ëª…, ê· í˜•)
        // type 3: ê³¨ë ˜ (ê°ˆìƒ‰, ë§¤ìš° ëŠë¦¼, ì²´ë ¥ ë§¤ìš° ë†’ìŒ)
        // type 4: ë°•ì¥ (íŒŒë‘, ë§¤ìš° ë¹ ë¦„, ì²´ë ¥ ë‚®ìŒ)
        // type 5: ê±°ì¸ (íšŒìƒ‰, ë§¤ìš° í¼, ëŠë¦¼, ëŒ ë˜ì§€ê¸°)
        
        if (forceType !== null) {
            this.type = forceType;
        } else if (stage <= 1) {
            // ë¼ìš´ë“œ 1: ìŠ¬ë¼ì„, ë°•ì¥ (2ì¢…ë¥˜)
            this.type = Math.random() < 0.6 ? 0 : 4;
        } else if (stage <= 2) {
            // ë¼ìš´ë“œ 2: 4ì¢…ë¥˜ (ìŠ¬ë¼ì„, ì•…ë§ˆ, ìœ ë ¹, ë°•ì¥)
            this.type = [0, 1, 2, 4][Math.floor(Math.random() * 4)];
        } else {
            // ë¼ìš´ë“œ 3+: 5ì¢…ë¥˜ (ê³¨ë ˜ ì¶”ê°€)
            this.type = Math.floor(Math.random() * 5);
        }
        
        // íƒ€ì…ë³„ ê¸°ë³¸ ìŠ¤íƒ¯
        // type 0: ìŠ¬ë¼ì„ (ëŠë¦¼, ì²´ë ¥ ë†’ìŒ)
        // type 1: ì•…ë§ˆ (ë¹ ë¦„, ê³µê²©ë ¥ ë†’ìŒ)
        // type 2: ìœ ë ¹ (ì¤‘ê°„, ê· í˜•)
        // type 3: ê³¨ë ˜ (ë§¤ìš° ëŠë¦¼, ì²´ë ¥ ë§¤ìš° ë†’ìŒ)
        // type 4: ë°•ì¥ (ë§¤ìš° ë¹ ë¦„, ì²´ë ¥ ë‚®ìŒ)
        // ê³µê²©ë ¥ ê³„ì‚°ìš© ìŠ¤í…Œì´ì§€ (ì¼ë°˜ ëª¨ë“œ: 5ë¼ìš´ë“œ ì´í›„ ê³ ì •, í•˜ë“œëª¨ë“œ: ê³„ì† ì¦ê°€)
        const dmgStage = hardMode ? stage : Math.min(stage, 5);
        const speedMultiplier = hardMode ? 1.1 : 1;  // í•˜ë“œëª¨ë“œ ì´ë™ì†ë„ 1.1ë°°
        
        if (this.type === 0) {
            // ìŠ¬ë¼ì„ - ëŠë¦¬ì§€ë§Œ ì²´ë ¥ ë†’ìŒ
            const baseHp = stage <= 2 ? 35 + stage * 12 : stage <= 5 ? 80 + stage * 25 : stage <= 7 ? 150 + stage * 45 : stage <= 9 ? 220 + stage * 60 : 300 + stage * 80;
            this.hp = baseHp * postBossMultiplier;
            this.speed = (1.2 + Math.random() * 0.3) * (1 + stage * 0.05) * speedMultiplier;
            const baseDmg = dmgStage <= 2 ? 8 + dmgStage * 2 : dmgStage <= 5 ? 12 + dmgStage * 3 : dmgStage <= 7 ? 18 + dmgStage * 4 : dmgStage <= 9 ? 26 + dmgStage * 5 : 35 + dmgStage * 6;
            this.damage = baseDmg * postBossMultiplier * (hardMode ? 1.3 : 1);
        } else if (this.type === 1) {
            // ì•…ë§ˆ - ë¹ ë¥´ê³  ê³µê²©ë ¥ ë†’ìŒ
            const baseHp = stage <= 2 ? 25 + stage * 8 : stage <= 5 ? 60 + stage * 18 : stage <= 7 ? 120 + stage * 35 : stage <= 9 ? 180 + stage * 50 : 250 + stage * 65;
            this.hp = baseHp * postBossMultiplier;
            this.speed = (2.2 + Math.random() * 0.5) * (1 + stage * 0.03) * speedMultiplier;
            const baseDmg = dmgStage <= 2 ? 12 + dmgStage * 3 : dmgStage <= 5 ? 18 + dmgStage * 4 : dmgStage <= 7 ? 28 + dmgStage * 5 : dmgStage <= 9 ? 40 + dmgStage * 6 : 55 + dmgStage * 8;
            this.damage = baseDmg * postBossMultiplier * (hardMode ? 1.3 : 1);
        } else if (this.type === 2) {
            // ìœ ë ¹ - ê· í˜•í˜•
            const baseHp = stage <= 2 ? 30 + stage * 10 : stage <= 5 ? 70 + stage * 20 : stage <= 7 ? 130 + stage * 40 : stage <= 9 ? 200 + stage * 55 : 280 + stage * 70;
            this.hp = baseHp * postBossMultiplier;
            this.speed = (1.7 + Math.random() * 0.4) * (1 + stage * 0.04) * speedMultiplier;
            const baseDmg = dmgStage <= 2 ? 10 + dmgStage * 2.5 : dmgStage <= 5 ? 15 + dmgStage * 3.5 : dmgStage <= 7 ? 22 + dmgStage * 4.5 : dmgStage <= 9 ? 32 + dmgStage * 5.5 : 45 + dmgStage * 7;
            this.damage = baseDmg * postBossMultiplier * (hardMode ? 1.3 : 1);
        } else if (this.type === 3) {
            // ê³¨ë ˜ - ë§¤ìš° ëŠë¦¬ì§€ë§Œ ì²´ë ¥ ë§¤ìš° ë†’ìŒ
            const baseHp = stage <= 2 ? 60 + stage * 20 : stage <= 5 ? 140 + stage * 40 : stage <= 7 ? 250 + stage * 65 : stage <= 9 ? 350 + stage * 85 : 450 + stage * 100;
            this.hp = baseHp * postBossMultiplier;
            this.speed = (0.7 + Math.random() * 0.2) * (1 + stage * 0.03) * speedMultiplier;
            const baseDmg = dmgStage <= 2 ? 15 + dmgStage * 3 : dmgStage <= 5 ? 22 + dmgStage * 4 : dmgStage <= 7 ? 32 + dmgStage * 5 : dmgStage <= 9 ? 45 + dmgStage * 6 : 60 + dmgStage * 8;
            this.damage = baseDmg * postBossMultiplier * (hardMode ? 1.3 : 1);
            this.size *= 1.3;  // ê³¨ë ˜ì€ í¬ê¸°ë„ í¼
        } else if (this.type === 4) {
            // ë°•ì¥ - ë§¤ìš° ë¹ ë¥´ì§€ë§Œ ì²´ë ¥ ë‚®ìŒ
            const baseHp = stage <= 2 ? 15 + stage * 5 : stage <= 5 ? 35 + stage * 12 : stage <= 7 ? 70 + stage * 25 : stage <= 9 ? 110 + stage * 35 : 150 + stage * 45;
            this.hp = baseHp * postBossMultiplier;
            this.speed = (3.0 + Math.random() * 0.8) * (1 + stage * 0.04) * speedMultiplier;
            const baseDmg = dmgStage <= 2 ? 6 + dmgStage * 1.5 : dmgStage <= 5 ? 9 + dmgStage * 2 : dmgStage <= 7 ? 14 + dmgStage * 3 : dmgStage <= 9 ? 20 + dmgStage * 4 : 28 + dmgStage * 5;
            this.damage = baseDmg * postBossMultiplier * (hardMode ? 1.3 : 1);
            this.size *= 0.7;  // ë°•ì¥ëŠ” í¬ê¸° ì‘ìŒ
        } else if (this.type === 5) {
            // ê±°ì¸ - ë§¤ìš° í¬ê³  ëŠë¦¬ì§€ë§Œ ì²´ë ¥ ì—„ì²­ ë†’ìŒ, ëŒ ë˜ì§€ê¸°
            const baseHp = stage <= 7 ? 300 + stage * 80 : stage <= 9 ? 450 + stage * 110 : 600 + stage * 140;
            this.hp = baseHp * postBossMultiplier;
            this.speed = (0.4 + Math.random() * 0.1) * (1 + stage * 0.02) * speedMultiplier;  // ë§¤ìš° ëŠë¦¼
            const baseDmg = dmgStage <= 7 ? 20 + dmgStage * 4 : dmgStage <= 9 ? 35 + dmgStage * 6 : 50 + dmgStage * 8;
            this.damage = baseDmg * postBossMultiplier * (hardMode ? 1.3 : 1);
            this.size = 55 + Math.random() * 15;  // í¬ê¸° ê³ ì • (ë§¤ìš° í¼)
            this.score = 100 + stage * 20;  // ë†’ì€ ì ìˆ˜
            this.exp = 80 + stage * 15;  // ë†’ì€ ê²½í—˜ì¹˜
        } else {
            // ê¸°ë³¸ê°’ (ìŠ¬ë¼ì„)
            const baseHp = stage <= 2 ? 35 + stage * 12 : stage <= 5 ? 60 + stage * 18 : stage <= 7 ? 100 + stage * 30 : stage <= 9 ? 150 + stage * 45 : 200 + stage * 60;
            this.hp = baseHp * postBossMultiplier;
            this.speed = (1.2 + Math.random() * 0.3) * (1 + stage * 0.05) * speedMultiplier;
            const baseDmg = dmgStage <= 2 ? 8 + dmgStage * 2 : dmgStage <= 5 ? 12 + dmgStage * 3 : dmgStage <= 7 ? 18 + dmgStage * 4 : dmgStage <= 9 ? 26 + dmgStage * 5 : 35 + dmgStage * 6;
            this.damage = baseDmg * postBossMultiplier * (hardMode ? 1.3 : 1);
        }
        
        // ì ìˆ˜ì™€ ê²½í—˜ì¹˜ (ë³´ìŠ¤ ì²˜ì¹˜ í›„ ì¦ê°€)
        if (stage <= 2) {
            this.score = (10 + stage * 5) * (1 + bossBonus * 0.3);
            this.exp = (10 + stage * 5) * (1 + bossBonus * 0.3);
        } else if (stage <= 5) {
            this.score = (20 + stage * 8) * (1 + bossBonus * 0.3);
            this.exp = (15 + stage * 8) * (1 + bossBonus * 0.3);
        } else {
            this.score = (30 + stage * 10) * (1 + bossBonus * 0.3);
            this.exp = (20 + stage * 10) * (1 + bossBonus * 0.3);
        }
        
        this.maxHp = this.hp;
        this.lastDmg = 0;
        this.frozen = false;
        this.burning = false;
        this.burningTime = 0;
        
        // ì›ê±°ë¦¬ ê³µê²© ì„¤ì •
        // type 1 ì•…ë§ˆ: 30% í™•ë¥ ë¡œ ì›ê±°ë¦¬
        // type 5 ê±°ì¸: í•­ìƒ ëŒ ë˜ì§€ê¸° (ëŠë¦° ì¿¨ë‹¤ìš´)
        if (this.type === 5) {
            this.canRangedAttack = true;
            this.rangedCooldown = 3500;  // 3.5ì´ˆ ì¿¨íƒ€ì„ (ëŠë¦¼)
            this.throwsRock = true;  // ëŒ ë˜ì§€ê¸° í”Œë˜ê·¸
        } else if (this.type === 1 && Math.random() < 0.3) {
            this.canRangedAttack = true;
            this.rangedCooldown = 2000;
            this.throwsRock = false;
        } else {
            this.canRangedAttack = false;
            this.throwsRock = false;
        }
        this.lastRangedAttack = 0;
    }
    
    update() {
        const p = G.player;
        const dx = p.x - this.x;
        const dy = p.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        // ===== ì´ë™ =====
        if (dist > this.size) {
            let moveSpeed = this.speed * gameSpeedMultiplier;  // í”„ë ˆì„ ì†ë„ ë³´ì •
            if (this.frozen) moveSpeed *= 0.3;  // ë¹™ê²° ìƒíƒœë©´ ì´ë™ì†ë„ ê°ì†Œ
            
            const moveX = (dx / dist) * moveSpeed;
            const moveY = (dy / dist) * moveSpeed;
            
            // ìƒˆ ìœ„ì¹˜ ê³„ì‚°
            const newX = this.x + moveX;
            const newY = this.y + moveY;
            
            // ì¥ì• ë¬¼ ì¶©ëŒ ê²€ì‚¬ (ë‹¨ìˆœí™”)
            let canMove = true;
            for (let obs of G.obstacles) {
                const obstDist = Math.hypot(newX - obs.x, newY - obs.y);
                if (obstDist < obs.size + this.size * 0.7) {
                    canMove = false;
                    break;
                }
            }
            
            // ì´ë™ ë˜ëŠ” ìš°íšŒ
            if (canMove) {
                this.x = newX;
                this.y = newY;
            } else {
                // ìš°íšŒ ì‹œë„ (ì™¼ìª½/ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì¡°ê¸ˆì”© ëŒì•„ê°€ê¸°)
                const oldX = this.x;
                const oldY = this.y;
                let moved = false;
                
                for (let angle of [0.5, -0.5, 1, -1]) {
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    const rotatedMoveX = moveX * cos - moveY * sin;
                    const rotatedMoveY = moveX * sin + moveY * cos;
                    
                    const newX = this.x + rotatedMoveX;
                    const newY = this.y + rotatedMoveY;
                    
                    // ì¥ì• ë¬¼ ì¶©ëŒ ê²€ì‚¬
                    let canMove = true;
                    for (let obs of G.obstacles) {
                        const obstDist = Math.hypot(newX - obs.x, newY - obs.y);
                        if (obstDist < obs.size + this.size * 0.7) {
                            canMove = false;
                            break;
                        }
                    }
                    
                    if (canMove) {
                        this.x = newX;
                        this.y = newY;
                        moved = true;
                        break;
                    }
                }
                
                // ìš°íšŒë„ ì‹¤íŒ¨í•˜ë©´ ì›ë˜ ìœ„ì¹˜ ìœ ì§€
                if (!moved) {
                    this.x = oldX;
                    this.y = oldY;
                }
            }
        }
        
        // ===== í”Œë ˆì´ì–´ ê³µê²© (ê³µê²© ë²”ìœ„ ê°ì†Œ) =====
        if (dist < this.size + 20) {  // ê³µê²© ë²”ìœ„: ì  í¬ê¸° + 20
            const now = Date.now();
            if (now - this.lastDmg > 1000) {
                p.takeDamage(this.damage);
                this.lastDmg = now;
            }
        }
        
        // ===== ì›ê±°ë¦¬ ê³µê²© (ì•…ë§ˆ: ë¶ˆê½ƒ, ê±°ì¸: ëŒ) =====
        if (this.canRangedAttack) {
            // ê±°ì¸ì€ ë” ë¨¼ ê±°ë¦¬ì—ì„œë„ ë˜ì§
            const minDist = this.throwsRock ? 80 : 100;
            const maxDist = this.throwsRock ? 400 : 300;
            
            if (dist < maxDist && dist > minDist) {
                const now = Date.now();
                if (now - this.lastRangedAttack > this.rangedCooldown) {
                    this.lastRangedAttack = now;
                    G.enemyProjectiles = G.enemyProjectiles || [];
                    const angle = Math.atan2(p.y - this.y, p.x - this.x);
                    
                    if (this.throwsRock) {
                        // ê±°ì¸ì˜ ëŒ ë˜ì§€ê¸° (ëŠë¦¬ì§€ë§Œ ê°•ë ¥)
                        G.enemyProjectiles.push({
                            x: this.x,
                            y: this.y,
                            vx: Math.cos(angle) * 2,  // ë§¤ìš° ëŠë¦¼
                            vy: Math.sin(angle) * 2,
                            damage: this.damage * 1.2,  // ë†’ì€ ë°ë¯¸ì§€
                            life: 250,
                            isRock: true,  // ëŒ í‘œì‹œ
                            size: 18  // í° í¬ê¸°
                        });
                    } else {
                        // ì•…ë§ˆì˜ ë¶ˆê½ƒ
                        G.enemyProjectiles.push({
                            x: this.x,
                            y: this.y,
                            vx: Math.cos(angle) * 3,
                            vy: Math.sin(angle) * 3,
                            damage: this.damage * 0.35,  // ê³µê²©ë ¥ ì ˆë°˜ìœ¼ë¡œ ê°ì†Œ
                            life: 180,
                            isRock: false,
                            size: 8
                        });
                    }
                }
            }
        }
        
        // ===== ìƒíƒœ ì´ìƒ íš¨ê³¼ (í™”ìƒ) =====
        // ê²Œì„ ì¼ì‹œì •ì§€ ì‹œì—ëŠ” ì ìš© ì•ˆ ë¨
        if (!G.paused) {
            if (this.burning && this.burningTime > 0) {
                this.hp -= 0.5;
                this.burningTime--;
                if (this.burningTime <= 0) {
                    this.burning = false;
                }
            }
        }
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.hp < this.maxHp) {
            ctx.fillStyle = '#333';
            ctx.fillRect(-this.size, -this.size - 12, this.size * 2, 4);
            ctx.fillStyle = this.isBoss ? '#ff0' : '#f00';
            ctx.fillRect(-this.size, -this.size - 12, this.size * 2 * (this.hp/this.maxHp), 4);
        }
        
        const scale = this.size / 20;
        const p = 2 * scale;
        const frame = Math.floor(Date.now() / 300) % 2;
        
        if (this.type === 0) {
            ctx.fillStyle = '#4a4';
            ctx.fillRect(-3*p, -4*p, 6*p, 8*p);
            ctx.fillStyle = '#333';
            ctx.fillRect(-2*p, 4*p, 2*p, 2*p - frame*p);
            ctx.fillRect(0, 4*p, 2*p, 2*p + frame*p);
            ctx.fillStyle = '#fff';
            ctx.fillRect(-1*p, -2*p, 0.5*p, 1*p);
            ctx.fillRect(0.5*p, -2*p, 0.5*p, 1*p);
            ctx.fillStyle = '#f00';
            ctx.fillRect(-1*p, -2*p, 0.5*p, 0.5*p);
            ctx.fillRect(0.5*p, -2*p, 0.5*p, 0.5*p);
        } else if (this.type === 1) {
            ctx.fillStyle = '#f44';
            ctx.fillRect(-3*p, -4*p, 6*p, 8*p);
            ctx.fillStyle = '#a00';
            ctx.fillRect(-3*p, -6*p, 1*p, 2*p);
            ctx.fillRect(2*p, -6*p, 1*p, 2*p);
            ctx.fillStyle = '#fff';
            ctx.fillRect(-1*p, -2*p, 0.5*p, 1*p);
            ctx.fillRect(0.5*p, -2*p, 0.5*p, 1*p);
            ctx.fillStyle = '#ff0';
            ctx.fillRect(-1*p, -2*p, 0.5*p, 0.5*p);
            ctx.fillRect(0.5*p, -2*p, 0.5*p, 0.5*p);
        } else if (this.type === 2) {
            // ìœ ë ¹ (ë³´ë¼ìƒ‰, ë°˜íˆ¬ëª…, ì¶œë ê±°ë¦¼)
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = '#a9f';
            for (let i = 0; i < 4; i++) {
                const wave = Math.sin(Date.now()/150 + i) * p/2;
                ctx.fillRect(-3*p + wave, -4*p + i*p*2, 6*p, p*1.5);
            }
            ctx.fillStyle = '#fff';
            ctx.fillRect(-1*p, -2*p, 0.5*p, 1*p);
            ctx.fillRect(0.5*p, -2*p, 0.5*p, 1*p);
            ctx.globalAlpha = 1;
        } else if (this.type === 3) {
            // ê³¨ë ˜ (ê°ˆìƒ‰, í¬ê³  ê°ì§„ í˜•íƒœ)
            ctx.fillStyle = '#8B4513';  // ê°ˆìƒ‰ ëª¸í†µ
            ctx.fillRect(-3.5*p, -4*p, 7*p, 9*p);
            ctx.fillStyle = '#654321';  // ì–´ë‘ìš´ ê°ˆìƒ‰ ê·¸ë¦¼ì
            ctx.fillRect(-3.5*p, -4*p, 2*p, 9*p);
            // ëŒ ë¬´ëŠ¬
            ctx.fillStyle = '#6B4423';
            ctx.fillRect(-2*p, -2*p, 1.5*p, 2*p);
            ctx.fillRect(1*p, 0, 1.5*p, 2*p);
            // ëˆˆ (ë¹¨ê°„ ë¹›)
            ctx.fillStyle = '#f00';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#f00';
            ctx.fillRect(-1.5*p, -2*p, 1*p, 0.8*p);
            ctx.fillRect(0.5*p, -2*p, 1*p, 0.8*p);
            ctx.shadowBlur = 0;
            // ë‹¤ë¦¬
            ctx.fillStyle = '#654321';
            ctx.fillRect(-2.5*p, 5*p, 2*p, 2*p - frame*p);
            ctx.fillRect(0.5*p, 5*p, 2*p, 2*p + frame*p);
        } else if (this.type === 4) {
            // ë°•ì¥ (íŒŒë€ìƒ‰/ë³´ë¼ìƒ‰, ë‚ ê°œ í„ëŸ­ì„)
            const wingFlap = Math.sin(Date.now() / 100) * p;
            ctx.fillStyle = '#4466aa';  // ëª¸í†µ
            ctx.fillRect(-2*p, -2*p, 4*p, 4*p);
            // ë‚ ê°œ
            ctx.fillStyle = '#223366';
            ctx.beginPath();
            ctx.moveTo(-2*p, 0);
            ctx.lineTo(-5*p, -2*p + wingFlap);
            ctx.lineTo(-4*p, 2*p + wingFlap * 0.5);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(2*p, 0);
            ctx.lineTo(5*p, -2*p - wingFlap);
            ctx.lineTo(4*p, 2*p - wingFlap * 0.5);
            ctx.closePath();
            ctx.fill();
            // ê·€
            ctx.fillStyle = '#4466aa';
            ctx.beginPath();
            ctx.moveTo(-1.5*p, -2*p);
            ctx.lineTo(-1*p, -4*p);
            ctx.lineTo(-0.5*p, -2*p);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(1.5*p, -2*p);
            ctx.lineTo(1*p, -4*p);
            ctx.lineTo(0.5*p, -2*p);
            ctx.closePath();
            ctx.fill();
            // ëˆˆ (ë¹¨ê°„ìƒ‰)
            ctx.fillStyle = '#ff0';
            ctx.fillRect(-1*p, -1*p, 0.6*p, 0.6*p);
            ctx.fillRect(0.4*p, -1*p, 0.6*p, 0.6*p);
        } else if (this.type === 5) {
            // ê±°ì¸ (íšŒìƒ‰, ë§¤ìš° í¼, ê·¼ìœ¡ì§ˆ)
            const breathe = Math.sin(Date.now() / 500) * p * 0.3;
            
            // ëª¸í†µ (í° ì‚¬ê°í˜•)
            ctx.fillStyle = '#556';
            ctx.fillRect(-4*p, -5*p + breathe, 8*p, 11*p);
            
            // ì–´ê¹¨/ê·¼ìœ¡
            ctx.fillStyle = '#667';
            ctx.fillRect(-5*p, -4*p + breathe, 2*p, 4*p);
            ctx.fillRect(3*p, -4*p + breathe, 2*p, 4*p);
            
            // ë‹¤ë¦¬ (ê±·ëŠ” ì• ë‹ˆë©”ì´ì…˜)
            ctx.fillStyle = '#445';
            ctx.fillRect(-3*p, 6*p, 2.5*p, 3*p - frame*p);
            ctx.fillRect(0.5*p, 6*p, 2.5*p, 3*p + frame*p);
            
            // íŒ” (ëŒì„ ë“¤ê³  ìˆëŠ” ë“¯í•œ í¬ì¦ˆ)
            ctx.fillStyle = '#556';
            ctx.fillRect(-6*p, -2*p + breathe, 2*p, 5*p);
            ctx.fillRect(4*p, -2*p + breathe, 2*p, 5*p);
            
            // ë¨¸ë¦¬
            ctx.fillStyle = '#667';
            ctx.fillRect(-2.5*p, -8*p + breathe, 5*p, 4*p);
            
            // ëˆˆ (ì‘ê³  ë¹¨ê°„ ë¹›)
            ctx.fillStyle = '#f44';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#f00';
            ctx.fillRect(-1.5*p, -6.5*p + breathe, 1*p, 0.8*p);
            ctx.fillRect(0.5*p, -6.5*p + breathe, 1*p, 0.8*p);
            ctx.shadowBlur = 0;
            
            // ì… (ì°¡ê·¸ë¦° í‘œì •)
            ctx.fillStyle = '#333';
            ctx.fillRect(-1.5*p, -5*p + breathe, 3*p, 0.5*p);
            
            // ì†ì— ëŒ (ë˜ì§€ê¸° ì¤€ë¹„)
            ctx.fillStyle = '#777';
            ctx.beginPath();
            ctx.arc(-6*p, 1*p + breathe, 1.5*p, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#999';
            ctx.beginPath();
            ctx.arc(-6.3*p, 0.7*p + breathe, 0.5*p, 0, Math.PI * 2);
            ctx.fill();
        }
        
        if (this.frozen) {
            ctx.fillStyle = 'rgba(100,200,255,0.4)';
            ctx.fillRect(-this.size, -this.size, this.size*2, this.size*2);
        }
        
        if (this.burning) {
            ctx.fillStyle = 'rgba(255,100,0,0.3)';
            ctx.fillRect(-this.size, -this.size, this.size*2, this.size*2);
        }
        
        ctx.restore();
    }
}

class Boss extends Enemy {
    constructor(x, y, level) {
        super(x, y, 1);
        
        this.isBoss = true;
        this.bossLevel = level;
        this.size = 60 + level * 10;
        // ì²´ë ¥ ëŒ€í­ ì¦ê°€ (ë ˆë²¨ë‹¹ ë” ê¸‰ê²©íˆ ì¦ê°€)
        this.hp = 1500 + level * 800;
        this.maxHp = this.hp;
        this.damage = 30 + level * 10;
        this.speed = hardMode ? 0.88 : 0.8;  // í•˜ë“œëª¨ë“œ: 1.1ë°°
        this.score = 1000;
        this.exp = 1000;
        this.type = 1;
        this.animPhase = 0;
        
        // ê³µê²© íŒ¨í„´ ê´€ë ¨
        this.attackCooldown = 30; // ì‹œì‘í•˜ìë§ˆì ê³µê²©
        this.currentAttack = null;
        this.attackPhase = 0;
        this.chargeTarget = null;
        this.isCharging = false;
        this.chargeSpeed = (10 + level * 2) * (hardMode ? 1.1 : 1);  // í•˜ë“œëª¨ë“œ: 1.1ë°°
        this.originalSpeed = this.speed;
        
        // íƒ„ë§‰ íŒ¨í„´ìš©
        this.burstCount = 0;
        this.burstMax = 3 + level * 2; // ì—°ì† ë°œì‚¬ íšŸìˆ˜
        this.spiralAngle = 0;
        
        // ë ˆì´ì € íŒ¨í„´ìš©
        this.laserAngle = 0;
        this.laserWarningEffect = null;
        
        // ê³µê²© ë²”ìœ„ í‘œì‹œìš©
        this.burstWarningEffect = null;
        this.spreadWarningEffect = null;
        
        // ê²½ê³  í‘œì‹œ í”Œë˜ê·¸
        this.burstWarningShown = false;
        this.spreadWarningShown = false;
        this.laserWarningShown = false;
        this.chargeWarningShown = false;
        this.slamWarningShown = false;
        this.spiralWarningShown = false;
        
        // ê³µê²© ì‹¤í–‰ í”Œë˜ê·¸ (ë°ë¯¸ì§€ ì¤‘ë³µ ë°©ì§€)
        this.chargeHit = false;
        this.slamExecuted = false;
    }
    
    update() {
        if (this.frozen) {
            this.frozenTime--;
            if (this.frozenTime <= 0) this.frozen = false;
            return;
        }
        
        const player = G.player;
        // í”Œë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ë¦¬í„´
        if (!player) return;
        
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        const angle = Math.atan2(dy, dx);
        
        // ê³µê²© ì¿¨ë‹¤ìš´ ê°ì†Œ
        if (this.attackCooldown > 0) {
            this.attackCooldown -= gameSpeedMultiplier;
        }
        
        // í˜„ì¬ ê³µê²© ì¤‘ì´ ì•„ë‹ˆê³  ì¿¨ë‹¤ìš´ì´ ëë‚¬ìœ¼ë©´ ìƒˆ ê³µê²© ì„ íƒ
        if (!this.currentAttack && this.attackCooldown <= 0) {
            this.selectAttack(dist);
        }
        
        // í˜„ì¬ ê³µê²© ì‹¤í–‰
        if (this.currentAttack) {
            this.executeAttack(player, dist, angle);
        } else {
            // ê³µê²© ì¤‘ì´ ì•„ë‹ ë•ŒëŠ” í”Œë ˆì´ì–´ë¥¼ í–¥í•´ ì´ë™
            if (dist > 100) {
                this.x += Math.cos(angle) * this.speed * gameSpeedMultiplier;
                this.y += Math.sin(angle) * this.speed * gameSpeedMultiplier;
            }
        }
        
        // ë§µ ê²½ê³„ ì œí•œ
        this.x = Math.max(this.size, Math.min(MAP_WIDTH - this.size, this.x));
        this.y = Math.max(this.size, Math.min(MAP_HEIGHT - this.size, this.y));
        
        // í”Œë ˆì´ì–´ ì¶©ëŒ ë°ë¯¸ì§€ (ë²”ìœ„ ì¶•ì†Œ - ê·¼ì ‘ ê³µê²© ê°€ëŠ¥í•˜ë„ë¡)
        if (dist < this.size * 0.5) {
            player.takeDamage(this.damage * 0.5);
        }
        
        // í™”ìƒ ë°ë¯¸ì§€
        if (this.burning && this.burnDamage && !isNaN(this.burnDamage)) {
            this.hp -= this.burnDamage * gameSpeedMultiplier;
            this.burnTime--;
            if (this.burnTime <= 0) this.burning = false;
        }
    }
    
    selectAttack(dist) {
        // ê±°ë¦¬ì™€ ë ˆë²¨ì— ë”°ë¼ ê³µê²© ì„ íƒ
        let attack;
        const rand = Math.random();
        
        // 1ë¼ìš´ë“œ ë³´ìŠ¤ (bossLevel 0)ëŠ” ê·¼ì ‘ ê³µê²©ë§Œ ì‚¬ìš©
        if (this.bossLevel === 0) {
            // ëŒì§„ê³¼ ìŠ¬ë¨ë§Œ ì‚¬ìš©
            if (dist > 200) {
                attack = 'charge';  // ë©€ë©´ ëŒì§„
            } else {
                attack = rand < 0.6 ? 'slam' : 'charge';  // ê°€ê¹Œìš°ë©´ ì£¼ë¡œ ìŠ¬ë¨
            }
        } else {
            // 2ë¼ìš´ë“œ ì´í›„ ë³´ìŠ¤ëŠ” ëª¨ë“  íŒ¨í„´ ì‚¬ìš© (ë ˆì´ì € í¬í•¨)
            const attacks = ['charge', 'slam', 'burst', 'spiral', 'spread', 'laser'];
            
            if (dist > 350) {
                // ë©€ë©´ ëŒì§„ ë˜ëŠ” íƒ„ë§‰ ë˜ëŠ” ë ˆì´ì €
                attack = rand < 0.25 ? 'charge' : (rand < 0.5 ? 'spiral' : (rand < 0.75 ? 'spread' : 'laser'));
            } else if (dist > 200) {
                // ì¤‘ê°„ ê±°ë¦¬
                attack = attacks[Math.floor(Math.random() * attacks.length)];
            } else {
                // ê°€ê¹Œìš°ë©´ ìŠ¬ë¨ ë˜ëŠ” íƒ„ë§‰ ë˜ëŠ” ë ˆì´ì €
                attack = rand < 0.25 ? 'slam' : (rand < 0.5 ? 'burst' : (rand < 0.75 ? 'spread' : 'laser'));
            }
        }
        
        this.currentAttack = attack;
        this.attackPhase = 0;
        this.burstCount = 0;
        
        if (attack === 'charge') {
            this.chargeTarget = { x: G.player.x, y: G.player.y };
            this.isCharging = false;
        }
        
        // ë ˆì´ì € ê³µê²© ì´ˆê¸°í™”
        if (attack === 'laser') {
            this.laserAngle = Math.atan2(G.player.y - this.y, G.player.x - this.x);
            this.laserWarningShown = false;
        }
    }
    
    executeAttack(player, dist, angle) {
        this.attackPhase += gameSpeedMultiplier;
        
        try {
            switch (this.currentAttack) {
                case 'charge':
                    this.doChargeAttack(player, angle);
                    break;
                case 'slam':
                    this.doSlamAttack(player, dist);
                    break;
                case 'burst':
                    this.doBurstAttack(player, angle);
                    break;
                case 'spiral':
                    this.doSpiralAttack(player, angle);
                    break;
                case 'spread':
                    this.doSpreadAttack(player, angle);
                    break;
                case 'laser':
                    this.doLaserAttack(player, angle);
                    break;
                default:
                    // ì•Œ ìˆ˜ ì—†ëŠ” ê³µê²©ì´ë©´ ë¦¬ì…‹
                    this.currentAttack = null;
                    this.attackCooldown = 30;
            }
        } catch (err) {
            console.error('Boss attack error:', err);
            // ì—ëŸ¬ ë°œìƒ ì‹œ ê³µê²© ë¦¬ì…‹
            this.currentAttack = null;
            this.attackCooldown = 30;
            this.isCharging = false;
        }
    }
    
    doChargeAttack(player, angle) {
        // chargeTargetì´ ì—†ìœ¼ë©´ í˜„ì¬ í”Œë ˆì´ì–´ ìœ„ì¹˜ë¡œ ì„¤ì •
        if (!this.chargeTarget) {
            this.chargeTarget = { x: player.x, y: player.y };
        }
        
        if (this.attackPhase < 40) {
            this.isCharging = false;
            if (this.attackPhase <= 2 && !this.chargeWarningShown) {
                this.chargeWarningShown = true;
                this.chargeHit = false; // ëŒì§„ íˆíŠ¸ í”Œë˜ê·¸ ì´ˆê¸°í™”
                G.textParticle(this.x, this.y - this.size - 30, 'ğŸ’¢', '#f00', 1);
            }
        } else if (this.attackPhase < 100) {
            this.isCharging = true;
            const targetDx = this.chargeTarget.x - this.x;
            const targetDy = this.chargeTarget.y - this.y;
            const targetDist = Math.hypot(targetDx, targetDy);
            
            if (targetDist > 20) {
                const chargeAngle = Math.atan2(targetDy, targetDx);
                this.x += Math.cos(chargeAngle) * this.chargeSpeed * gameSpeedMultiplier;
                this.y += Math.sin(chargeAngle) * this.chargeSpeed * gameSpeedMultiplier;
                
                // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ ì‹œ ë°ë¯¸ì§€ (í•œ ë²ˆë§Œ)
                const playerDist = Math.hypot(player.x - this.x, player.y - this.y);
                if (playerDist < this.size + 25 && !this.chargeHit) {
                    this.chargeHit = true;
                    player.takeDamage(this.damage * 1.5);
                    G.screenShake = 15;
                    this.attackPhase = 100;
                }
            } else {
                this.attackPhase = 100;
            }
        } else if (this.attackPhase < 120) {
            this.isCharging = false;
        } else {
            this.currentAttack = null;
            this.isCharging = false;
            this.chargeWarningShown = false;
            this.chargeHit = false;
            this.attackCooldown = 40 + Math.random() * 30;
        }
    }
    
    doSlamAttack(player, dist) {
        if (this.attackPhase < 30) {
            if (this.attackPhase <= 2 && !this.slamWarningShown) {
                this.slamWarningShown = true;
                this.slamExecuted = false; // ìŠ¬ë¨ ì‹¤í–‰ í”Œë˜ê·¸ ì´ˆê¸°í™”
                G.textParticle(this.x, this.y - this.size - 30, 'âš¡', '#ff0', 1);
            }
        } else if (this.attackPhase >= 30 && !this.slamExecuted) {
            // ìŠ¬ë¨ì€ í•œ ë²ˆë§Œ ì‹¤í–‰
            this.slamExecuted = true;
            G.screenShake = 25;
            
            G.effects.push({
                type: 'shockwave',
                x: this.x,
                y: this.y,
                radius: 0,
                maxRadius: 180 + this.bossLevel * 40,
                life: 25
            });
            
            if (dist < 180 + this.bossLevel * 40) {
                player.takeDamage(this.damage * 1.3);
            }
            
            // ìŠ¬ë¨ í›„ ë°©ì‚¬í˜• íƒ„ë§‰ ë°œì‚¬ (2ë¼ìš´ë“œ ì´í›„ ë³´ìŠ¤ë§Œ)
            if (this.bossLevel >= 1) {
                const bulletCount = 8 + this.bossLevel * 4;
                for (let i = 0; i < bulletCount; i++) {
                    const bulletAngle = (i / bulletCount) * Math.PI * 2;
                    G.enemyProjectiles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(bulletAngle) * 4,
                        vy: Math.sin(bulletAngle) * 4,
                        damage: this.damage * 0.5,
                        life: 150,
                        isBossProjectile: true,
                        size: 10
                    });
                }
            }
        }
        
        if (this.attackPhase > 70) {
            this.currentAttack = null;
            this.slamWarningShown = false;
            this.slamExecuted = false;
            this.attackCooldown = 50 + Math.random() * 30;
        }
    }
    
    // ì—°ì† ë°œì‚¬ íŒ¨í„´ (íƒ„ë§‰)
    doBurstAttack(player, angle) {
        const burstInterval = 12; // ë°œì‚¬ ê°„ê²© (8â†’12ë¡œ ì¦ê°€)
        const totalBursts = this.burstMax;
        const spreadAngle = Math.PI / 4; // 45ë„ ë²”ìœ„
        const warningTime = 35; // ê²½ê³  ì‹œê°„ (ì•½ 0.6ì´ˆ)
        
        // ì²« í”„ë ˆì„ì— ê²½ê³  ì´í™íŠ¸ ìƒì„± (ë²”ìœ„ ì²´í¬ë¡œ ë³€ê²½)
        if (this.attackPhase <= 2 && !this.burstWarningShown) {
            this.burstWarningShown = true;
            // ë°œì‚¬ ë°©í–¥ ê³ ì • (ê²½ê³  ì‹œì ì˜ í”Œë ˆì´ì–´ ìœ„ì¹˜ë¡œ)
            this.burstFixedAngle = Math.atan2(player.y - this.y, player.x - this.x);
            G.textParticle(this.x, this.y - this.size - 30, 'ğŸ”¥', '#f80', 1);
            // ê³µê²© ë²”ìœ„ í‘œì‹œ ì´í™íŠ¸ ì¶”ê°€
            this.burstWarningEffect = {
                type: 'attackWarning',
                x: this.x,
                y: this.y,
                angle: this.burstFixedAngle,
                spreadAngle: spreadAngle,
                range: 350,
                life: warningTime,
                maxLife: warningTime,
                color: '#ff8800'
            };
            G.effects.push(this.burstWarningEffect);
        }
        
        // ê²½ê³  ì¤‘ ë²”ìœ„ ì—…ë°ì´íŠ¸ (ìœ„ì¹˜ë§Œ, ë°©í–¥ì€ ê³ ì •)
        if (this.attackPhase <= warningTime && this.burstWarningEffect && this.burstWarningEffect.life > 0) {
            this.burstWarningEffect.x = this.x;
            this.burstWarningEffect.y = this.y;
            // ë°©í–¥ì€ ê³ ì • (ì¶”ì  ì•ˆí•¨)
        }
        
        // ì—°ì† ë°œì‚¬ (ê²½ê³  í›„ ì‹œì‘)
        if (this.attackPhase > warningTime && this.burstCount < totalBursts) {
            if ((this.attackPhase - warningTime) % burstInterval < 1) {
                const bulletCount = 5 + this.bossLevel * 2;
                
                // ê³ ì •ëœ ë°©í–¥ìœ¼ë¡œ ë°œì‚¬ (ì¶”ì  ì•ˆí•¨)
                const fixedAngle = this.burstFixedAngle || angle;
                
                for (let i = 0; i < bulletCount; i++) {
                    const offsetAngle = fixedAngle + (i - (bulletCount - 1) / 2) * (spreadAngle / (bulletCount - 1));
                    const speed = 6 + this.bossLevel;
                    
                    G.enemyProjectiles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(offsetAngle) * speed,
                        vy: Math.sin(offsetAngle) * speed,
                        damage: this.damage * 0.6,
                        life: 120,
                        isBossProjectile: true,
                        size: 10
                    });
                }
                this.burstCount++;
            }
        }
        
        if (this.attackPhase > warningTime + totalBursts * burstInterval + 20) {
            this.currentAttack = null;
            this.burstWarningEffect = null;
            this.burstWarningShown = false;
            this.burstFixedAngle = null;
            this.attackCooldown = 30 + Math.random() * 20;
        }
    }
    
    // ë‚˜ì„ í˜• íƒ„ë§‰ íŒ¨í„´
    doSpiralAttack(player, angle) {
        const duration = 120 + this.bossLevel * 30;
        
        if (this.attackPhase <= 2 && !this.spiralWarningShown) {
            this.spiralWarningShown = true;
            G.textParticle(this.x, this.y - this.size - 30, 'ğŸŒ€', '#0ff', 1);
            this.spiralAngle = 0;
        }
        
        // ë‚˜ì„ í˜•ìœ¼ë¡œ íƒ„ë§‰ ë°œì‚¬
        if (this.attackPhase > 10 && this.attackPhase < duration) {
            if (this.attackPhase % 5 < 1) { // 5í”„ë ˆì„ë§ˆë‹¤ ë°œì‚¬ (3â†’5ë¡œ ì¦ê°€)
                const arms = 2 + Math.floor(this.bossLevel / 2); // ë‚˜ì„  íŒ” ê°œìˆ˜
                const speed = 3 + this.bossLevel * 0.5;
                
                for (let i = 0; i < arms; i++) {
                    const bulletAngle = this.spiralAngle + (i / arms) * Math.PI * 2;
                    G.enemyProjectiles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(bulletAngle) * speed,
                        vy: Math.sin(bulletAngle) * speed,
                        damage: this.damage * 0.4,
                        life: 180,
                        isBossProjectile: true,
                        size: 8
                    });
                }
                this.spiralAngle += 0.25; // íšŒì „ ì†ë„ (0.2â†’0.25ë¡œ ì¦ê°€)
            }
        }
        
        if (this.attackPhase > duration + 30) {
            this.currentAttack = null;
            this.spiralWarningShown = false;
            this.attackCooldown = 40 + Math.random() * 30;
        }
    }
    
    // ë¶€ì±„ê¼´ í™•ì‚° íŒ¨í„´
    doSpreadAttack(player, angle) {
        const waves = 3 + this.bossLevel;
        const waveInterval = 35; // ì›¨ì´ë¸Œ ê°„ê²© (25â†’35ë¡œ ì¦ê°€)
        const spreadAngle = Math.PI / 2; // 90ë„ ë²”ìœ„ (144ë„ì—ì„œ ì¶•ì†Œ)
        const warningTime = 40; // ê²½ê³  ì‹œê°„ (ì•½ 0.67ì´ˆ)
        
        // ì²« í”„ë ˆì„ì— ê²½ê³  ì´í™íŠ¸ ìƒì„± (ë²”ìœ„ ì²´í¬ë¡œ ë³€ê²½)
        if (this.attackPhase <= 2 && !this.spreadWarningShown) {
            this.spreadWarningShown = true;
            // ë°œì‚¬ ë°©í–¥ ê³ ì • (ê²½ê³  ì‹œì ì˜ í”Œë ˆì´ì–´ ìœ„ì¹˜ë¡œ)
            this.spreadFixedAngle = Math.atan2(player.y - this.y, player.x - this.x);
            G.textParticle(this.x, this.y - this.size - 30, 'ğŸ’¥', '#f0f', 1);
            // ê³µê²© ë²”ìœ„ í‘œì‹œ ì´í™íŠ¸ ì¶”ê°€
            this.spreadWarningEffect = {
                type: 'attackWarning',
                x: this.x,
                y: this.y,
                angle: this.spreadFixedAngle,
                spreadAngle: spreadAngle,
                range: 400,
                life: warningTime,
                maxLife: warningTime,
                color: '#ff00ff'
            };
            G.effects.push(this.spreadWarningEffect);
        }
        
        // ê²½ê³  ì¤‘ ë²”ìœ„ ì—…ë°ì´íŠ¸ (ìœ„ì¹˜ë§Œ, ë°©í–¥ì€ ê³ ì •)
        if (this.attackPhase <= warningTime && this.spreadWarningEffect && this.spreadWarningEffect.life > 0) {
            this.spreadWarningEffect.x = this.x;
            this.spreadWarningEffect.y = this.y;
            // ë°©í–¥ì€ ê³ ì • (ì¶”ì  ì•ˆí•¨)
        }
        
        // ì—¬ëŸ¬ ë²ˆ í™•ì‚° ë°œì‚¬ (ê²½ê³  í›„ ì‹œì‘)
        if (this.attackPhase > warningTime) {
            const waveNum = Math.floor((this.attackPhase - warningTime) / waveInterval);
            const wavePhase = (this.attackPhase - warningTime) % waveInterval;
            
            if (waveNum < waves && wavePhase < 1) {
                const bulletCount = 12 + this.bossLevel * 3;
                // ê³ ì •ëœ ë°©í–¥ìœ¼ë¡œ ë°œì‚¬ (ì¶”ì  ì•ˆí•¨)
                const fixedAngle = this.spreadFixedAngle || angle;
                
                for (let i = 0; i < bulletCount; i++) {
                    const offsetAngle = fixedAngle + (i - (bulletCount - 1) / 2) * (spreadAngle / (bulletCount - 1));
                    // ì†ë„ì— ì•½ê°„ì˜ ëœë¤ì„± ì¶”ê°€
                    const speed = 4 + this.bossLevel * 0.5 + Math.random() * 2;
                    
                    G.enemyProjectiles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(offsetAngle) * speed,
                        vy: Math.sin(offsetAngle) * speed,
                        damage: this.damage * 0.5,
                        life: 150,
                        isBossProjectile: true,
                        size: 9
                    });
                }
            }
        }
        
        if (this.attackPhase > warningTime + waves * waveInterval + 30) {
            this.currentAttack = null;
            this.spreadWarningEffect = null;
            this.spreadWarningShown = false;
            this.spreadFixedAngle = null;
            this.attackCooldown = 35 + Math.random() * 25;
        }
    }
    
    // ì˜ˆê³  ë ˆì´ì € íŒ¨í„´ (ë°©í–¥ í‘œì‹œ í›„ ì§‘ì¤‘ íƒ„ë§‰)
    doLaserAttack(player, angle) {
        const warningDuration = 60; // ê²½ê³  í‘œì‹œ ì‹œê°„ (1ì´ˆ)
        const fireDelay = 70; // ë°œì‚¬ ì‹œì‘ ì‹œê°„
        const fireDuration = 40; // ë°œì‚¬ ì§€ì† ì‹œê°„
        
        // laserAngle ì´ˆê¸°í™” í™•ì¸ (ì•ˆì „ ì¥ì¹˜)
        if (this.laserAngle === undefined || this.laserAngle === null || isNaN(this.laserAngle)) {
            this.laserAngle = Math.atan2(player.y - this.y, player.x - this.x);
        }
        
        // ì²« í”„ë ˆì„ì— ê²½ê³  ì´í™íŠ¸ ìƒì„± (ë²”ìœ„ ì²´í¬ë¡œ ë³€ê²½)
        if (this.attackPhase <= 2 && !this.laserWarningShown) {
            this.laserWarningShown = true;
            G.textParticle(this.x, this.y - this.size - 30, 'âš¡', '#f00', 1.5);
            // ê²½ê³  ì´í™íŠ¸ ì¶”ê°€
            this.laserWarningEffect = {
                type: 'laserWarning',
                x: this.x,
                y: this.y,
                angle: this.laserAngle,
                life: warningDuration,
                maxLife: warningDuration
            };
            G.effects.push(this.laserWarningEffect);
        }
        
        // ê²½ê³  ì¤‘ì—ëŠ” ë³´ìŠ¤ê°€ í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ì²œì²œíˆ ì¡°ì¤€ ì¡°ì •
        if (this.attackPhase < warningDuration) {
            const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
            // ë¶€ë“œëŸ¬ìš´ ì¶”ì  (ë¹ ë¥´ê²Œ ì›€ì§ì´ë©´ í”¼í•  ìˆ˜ ìˆìŒ)
            const angleDiff = targetAngle - this.laserAngle;
            // ê°ë„ ì°¨ì´ë¥¼ -PI ~ PI ë²”ìœ„ë¡œ ì •ê·œí™”
            const normalizedDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
            this.laserAngle += normalizedDiff * 0.03; // ì²œì²œíˆ ì¶”ì 
            
            // ê²½ê³  ì´í™íŠ¸ ìœ„ì¹˜ì™€ ê°ë„ ì—…ë°ì´íŠ¸ (ì´í™íŠ¸ê°€ ì•„ì§ ì¡´ì¬í•˜ëŠ” ê²½ìš°ë§Œ)
            if (this.laserWarningEffect && this.laserWarningEffect.life > 0) {
                this.laserWarningEffect.x = this.x;
                this.laserWarningEffect.y = this.y;
                this.laserWarningEffect.angle = this.laserAngle;
            }
        }
        
        // íƒ„ë§‰ ë°œì‚¬ ì‹œì‘
        if (this.attackPhase >= fireDelay && this.attackPhase < fireDelay + fireDuration) {
            // 4í”„ë ˆì„ë§ˆë‹¤ íƒ„ë§‰ ë°œì‚¬
            if ((this.attackPhase - fireDelay) % 4 < 1) {
                const bulletCount = 8 + this.bossLevel * 2; // í•œ ë²ˆì— ë°œì‚¬í•˜ëŠ” íƒ„ë§‰ ìˆ˜
                const spreadAngle = Math.PI / 8; // ì¢ì€ ë²”ìœ„ (22.5ë„)
                const speed = 7 + this.bossLevel;
                
                for (let i = 0; i < bulletCount; i++) {
                    // ì¢ì€ ë²”ìœ„ ë‚´ì—ì„œ ì•½ê°„ì˜ í¼ì§
                    const offsetAngle = this.laserAngle + (Math.random() - 0.5) * spreadAngle;
                    // ì†ë„ì—ë„ ì•½ê°„ì˜ ë³€í™”
                    const bulletSpeed = speed + Math.random() * 2;
                    
                    G.enemyProjectiles.push({
                        x: this.x + Math.cos(this.laserAngle) * 30,
                        y: this.y + Math.sin(this.laserAngle) * 30,
                        vx: Math.cos(offsetAngle) * bulletSpeed,
                        vy: Math.sin(offsetAngle) * bulletSpeed,
                        damage: this.damage * 0.5,
                        life: 120,
                        isBossProjectile: true,
                        size: 8,
                        isLaserBullet: true
                    });
                }
            }
        }
        
        if (this.attackPhase > fireDelay + fireDuration + 30) {
            this.currentAttack = null;
            this.laserWarningEffect = null; // ì°¸ì¡° ì •ë¦¬
            this.laserWarningShown = false;
            this.attackCooldown = 50 + Math.random() * 30;
        }
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        this.animPhase += 0.05;
        const pulse = Math.sin(this.animPhase) * 0.1 + 1;
        const breathe = Math.sin(this.animPhase * 0.5) * 3;
        const eyeGlow = Math.sin(this.animPhase * 2) * 0.3 + 0.7;
        
        // ëŒì§„ ì¤‘ì¼ ë•Œ ë¹¨ê°„ ì”ìƒ íš¨ê³¼
        if (this.isCharging) {
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(0, 0, this.size * 1.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        
        // ì²´ë ¥ë°”
        ctx.fillStyle = '#222';
        ctx.fillRect(-this.size - 5, -this.size - 25, this.size * 2 + 10, 14);
        ctx.strokeStyle = '#f00';
        ctx.lineWidth = 2;
        ctx.strokeRect(-this.size - 5, -this.size - 25, this.size * 2 + 10, 14);
        
        const hpRatio = this.hp / this.maxHp;
        const hpGradient = ctx.createLinearGradient(-this.size, 0, this.size, 0);
        hpGradient.addColorStop(0, '#ff0');
        hpGradient.addColorStop(0.5, '#f80');
        hpGradient.addColorStop(1, '#f00');
        ctx.fillStyle = hpGradient;
        ctx.fillRect(-this.size - 2, -this.size - 22, (this.size * 2 + 4) * hpRatio, 8);
        
        // BOSS í…ìŠ¤íŠ¸
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('BOSS', 0, -this.size - 30);
        
        const scale = this.size / 20;
        const p = 3 * scale;
        
        // ì•„ìš°ë¼ íš¨ê³¼
        ctx.shadowBlur = 40 * pulse;
        ctx.shadowColor = this.bossLevel >= 2 ? '#f0f' : '#f00';
        
        // ë‚ ê°œ/ë§í† 
        if (this.bossLevel >= 1) {
            ctx.fillStyle = 'rgba(100, 0, 50, 0.7)';
            ctx.beginPath();
            ctx.moveTo(-3*p, -3*p);
            ctx.lineTo(-7*p - breathe, -6*p);
            ctx.lineTo(-6*p, 0);
            ctx.lineTo(-3*p, 4*p);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(3*p, -3*p);
            ctx.lineTo(7*p + breathe, -6*p);
            ctx.lineTo(6*p, 0);
            ctx.lineTo(3*p, 4*p);
            ctx.closePath();
            ctx.fill();
        }
        
        // ëª¸í†µ
        const bodyGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 4*p);
        bodyGradient.addColorStop(0, '#f66');
        bodyGradient.addColorStop(0.5, '#c00');
        bodyGradient.addColorStop(1, '#600');
        ctx.fillStyle = bodyGradient;
        ctx.fillRect(-3*p, -4*p + breathe, 6*p, 9*p);
        
        // ê°‘ì˜· ì¥ì‹
        ctx.fillStyle = '#444';
        ctx.fillRect(-2.5*p, -3*p + breathe, 5*p, 1*p);
        ctx.fillRect(-2.5*p, -1*p + breathe, 5*p, 0.5*p);
        ctx.fillRect(-2.5*p, 1*p + breathe, 5*p, 0.5*p);
        
        // ì–´ê¹¨ ê°‘ì˜·
        ctx.fillStyle = '#555';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#f00';
        ctx.beginPath();
        ctx.arc(-3.5*p, -2*p + breathe, 1.5*p, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(3.5*p, -2*p + breathe, 1.5*p, 0, Math.PI * 2);
        ctx.fill();
        
        // ì–´ê¹¨ ìŠ¤íŒŒì´í¬
        ctx.fillStyle = '#888';
        ctx.beginPath();
        ctx.moveTo(-3.5*p, -3.5*p + breathe);
        ctx.lineTo(-4.2*p, -5*p + breathe);
        ctx.lineTo(-2.8*p, -3.5*p + breathe);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(3.5*p, -3.5*p + breathe);
        ctx.lineTo(4.2*p, -5*p + breathe);
        ctx.lineTo(2.8*p, -3.5*p + breathe);
        ctx.closePath();
        ctx.fill();
        
        // ë¿”
        const hornGradient = ctx.createLinearGradient(0, -7*p, 0, -4*p);
        hornGradient.addColorStop(0, '#ffd700');
        hornGradient.addColorStop(1, '#8b0000');
        ctx.fillStyle = hornGradient;
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff0';
        
        ctx.beginPath();
        ctx.moveTo(-1.5*p, -4*p + breathe);
        ctx.lineTo(-3*p, -9*p + breathe);
        ctx.lineTo(-0.5*p, -4*p + breathe);
        ctx.closePath();
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(1.5*p, -4*p + breathe);
        ctx.lineTo(3*p, -9*p + breathe);
        ctx.lineTo(0.5*p, -4*p + breathe);
        ctx.closePath();
        ctx.fill();
        
        // ë¨¸ë¦¬
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#c00';
        ctx.fillRect(-2*p, -4*p + breathe, 4*p, 3*p);
        
        // ì´ë§ˆ ì¥ì‹
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.moveTo(0, -4*p + breathe);
        ctx.lineTo(-0.8*p, -3*p + breathe);
        ctx.lineTo(0, -2.5*p + breathe);
        ctx.lineTo(0.8*p, -3*p + breathe);
        ctx.closePath();
        ctx.fill();
        
        // ëˆˆ
        ctx.shadowBlur = 20 * eyeGlow;
        ctx.shadowColor = '#ff0';
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-1*p, -2.5*p + breathe, 0.7*p, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(1*p, -2.5*p + breathe, 0.7*p, 0, Math.PI * 2);
        ctx.fill();
        
        // ëˆˆë™ì
        const eyeMove = Math.sin(this.animPhase * 0.3) * 0.2*p;
        ctx.fillStyle = '#f00';
        ctx.shadowColor = '#f00';
        ctx.beginPath();
        ctx.arc(-1*p + eyeMove, -2.5*p + breathe, 0.4*p, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(1*p + eyeMove, -2.5*p + breathe, 0.4*p, 0, Math.PI * 2);
        ctx.fill();
        
        // ì…
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#300';
        ctx.fillRect(-1.5*p, -1.3*p + breathe, 3*p, 1*p);
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(-1.2*p + i * 0.8*p, -1.3*p + breathe);
            ctx.lineTo(-0.8*p + i * 0.8*p, -0.5*p + breathe);
            ctx.lineTo(-0.4*p + i * 0.8*p, -1.3*p + breathe);
            ctx.closePath();
            ctx.fill();
        }
        
        // ë‹¤ë¦¬
        ctx.fillStyle = '#500';
        const legMove = Math.sin(this.animPhase * 2) * p * 0.5;
        ctx.fillRect(-2*p, 5*p, 1.5*p, 3*p - legMove);
        ctx.fillRect(0.5*p, 5*p, 1.5*p, 3*p + legMove);
        
        // ë°œ
        ctx.fillStyle = '#444';
        ctx.fillRect(-2.3*p, 7.5*p - legMove, 2*p, 1*p);
        ctx.fillRect(0.3*p, 7.5*p + legMove, 2*p, 1*p);
        
        // ë ˆë²¨ 2+ ë³´ìŠ¤: í™”ì—¼ ì•„ìš°ë¼
        if (this.bossLevel >= 2) {
            ctx.globalAlpha = 0.3 + Math.sin(this.animPhase * 3) * 0.1;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + this.animPhase;
                const flameX = Math.cos(angle) * 5*p;
                const flameY = Math.sin(angle) * 5*p;
                ctx.fillStyle = i % 2 === 0 ? '#f80' : '#ff0';
                ctx.beginPath();
                ctx.arc(flameX, flameY, p, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, angle, owner, isArrow = false) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.vx = Math.cos(angle) * 10;
        this.vy = Math.sin(angle) * 10;
        this.owner = owner;
        this.damage = owner.damage;
        this.pierce = owner.pierce;
        this.hit = new Set();
        this.isArrow = isArrow;
    }
    
    update() {
        this.x += this.vx * gameSpeedMultiplier;
        this.y += this.vy * gameSpeedMultiplier;
        
        if (Math.abs(this.x - this.owner.x) > 400 || Math.abs(this.y - this.owner.y) > 400) {
            return false;
        }
        
        // ì¥ì• ë¬¼ ì¶©ëŒ ê²€ì‚¬
        for (let obs of G.obstacles) {
            const obstDist = Math.hypot(this.x - obs.x, this.y - obs.y);
            if (obstDist < obs.size) {
                return false; // íˆ¬ì‚¬ì²´ ì†Œë©¸
            }
        }
        
        for (let e of G.enemies) {
            if (!this.hit.has(e) && Math.hypot(e.x - this.x, e.y - this.y) < e.size + 8) {
                this.owner.dealDamage(e, this.damage);
                this.hit.add(e);
                if (this.pierce <= 0) return false;
                this.pierce--;
            }
        }
        
        return true;
    }
    
    draw() {
        ctx.save();
        
        if (this.isArrow) {
            // ê¶ìˆ˜ í™”ì‚´
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            // í™”ì‚´ ëª¸í†µ
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-12, -1, 20, 2);
            
            // í™”ì‚´ì´‰
            ctx.fillStyle = '#C0C0C0';
            ctx.beginPath();
            ctx.moveTo(8, 0);
            ctx.lineTo(2, -3);
            ctx.lineTo(2, 3);
            ctx.closePath();
            ctx.fill();
            
            // ê¹ƒí„¸
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.moveTo(-12, 0);
            ctx.lineTo(-15, -2);
            ctx.lineTo(-12, -1);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(-12, 0);
            ctx.lineTo(-15, 2);
            ctx.lineTo(-12, 1);
            ctx.closePath();
            ctx.fill();
        } else {
            // ë§ˆë²•ì‚¬ ë§ˆë²•íƒ„
            ctx.fillStyle = '#0ff';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#0ff';
            ctx.beginPath();
            ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
}

G.init();
</script>
  <script src="../js/math-explorer-bridge.js"></script>
</body>
</html>
