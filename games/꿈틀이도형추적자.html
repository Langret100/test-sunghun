<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê¿ˆí‹€ê¿ˆí‹€ ë„í˜• ì¶”ì ì</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&display=swap');
        
        /* 1. ê¸°ë³¸ ë ˆì´ì•„ì›ƒ: í™”ë©´ ì¤‘ì•™ ì •ë ¬ ë° ì „ì²´ ë†’ì´ í™•ë³´ */
        html, body {
            height: 100%; 
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Jua', sans-serif;
            background-color: #f7fee7; 
            color: #1a472a; 
            display: flex;
            justify-content: center;
            align-items: center; 
            min-height: 100vh;
            padding: 15px; 
            box-sizing: border-box; 
            overflow-y: auto; 
            font-size: 1.1rem; 
        }
        
        /* 2. ê²Œì„ ì»¨í…Œì´ë„ˆ (ë†’ì´ 100% í™•ë³´) */
        .game-container {
            background-color: #fff;
            padding: 30px; 
            border-radius: 16px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            max-width: 95vw;
            width: 100%; 
            max-height: 92vh; 
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 25px; 
        }
        
        /* ìº”ë²„ìŠ¤ */
        #gameCanvas {
            border: 4px solid #38a169;
            background-color: #e6fffa;
            border-radius: 12px;
            touch-action: none; 
            width: 100%; 
            height: 220px; 
            min-height: 220px; 
            flex-grow: 0; /* ëª¨ë°”ì¼ ê°€ì‹œì„± í™•ë³´ë¥¼ ìœ„í•´ ë†’ì´ ê³ ì • (ê¸°ì¡´ì˜ ì•½ 2/3 í¬ê¸°) */
        }

        /* 3. PC/íƒœë¸”ë¦¿ í™˜ê²½ ìµœì í™” (640px ì´ìƒ) */
        @media (min-width: 640px) {
            body {
                overflow-y: hidden; 
            }
            .game-container {
                padding: 50px;
                gap: 20px; 
                max-width: 90vw; 
                width: 90vw; 
                height: 95vh; /* ì „ì²´ ë†’ì´ ê¸°ì¤€ */
                min-height: 95vh; 
            }
            
            /* í•µì‹¬ ìˆ˜ì •: ìº”ë²„ìŠ¤ê°€ ë‚¨ì€ ê³µê°„ì„ ì°¨ì§€í•˜ë„ë¡ calc() ëŒ€ì‹  flex-growë¥¼ ì‚¬ìš©í•˜ê³ , 
               ë‹¤ë¥¸ ìš”ì†Œë“¤ì˜ ë†’ì´ë¥¼ ìµœì†Œí™”í•˜ì—¬ ê³µê°„ì„ ìµœëŒ€í™”í•©ë‹ˆë‹¤. */
            #gameCanvas {
                flex-grow: 1; 
                min-height: 380px; 
            }
        }
        
        /* 4. í†µê³„ ë°” ë° í…ìŠ¤íŠ¸ ì¡°ì • */
        .game-container h1 {
            margin-bottom: 0 !important; 
        }
        .stat-bar {
            background-color: #d1fae5;
            padding: 15px 25px; 
            border-radius: 10px;
            font-size: 1.1rem; 
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #flavor-text {
            display: none;
        }
        .prompt-text {
            font-size: 1.4rem; 
            font-weight: bold;
            margin-top: 0; 
            margin-bottom: 0;
        }

        /* 5. ì„ íƒ ë²„íŠ¼ ê·¸ë¦¬ë“œ ì¡°ì • */
        .choice-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px; 
            margin-top: 10px;
        }
        .choice-button {
            background-color: #9ae6b4;
            color: #1a472a;
            padding: 14px 8px; 
            border-radius: 10px;
            font-size: 1.4rem; 
            font-weight: bold;
            transition: all 0.15s ease;
            border: 3px solid #38a169; 
            cursor: pointer;
            word-break: keep-all;
            text-align: center;
        }
        
        @media (min-width: 640px) { 
            .choice-button {
                font-size: 1.8rem; 
                padding: 16px 10px; 
            }
        }

        
        /* ì ìˆ˜/ë¼ìš´ë“œ/ì‹œê°„ ìˆ«ì í¬ê¸° í‚¤ìš°ê¸° */
        #scoreDisplay,
        #roundDisplay,
        #timeDisplay {
            font-size: 1.4em;
        }
/* 6. ì œì¶œ ë²„íŠ¼ */
        .submit-button {
            background-color: #4299e1;
            color: white;
            padding: 14px 32px; 
            border-radius: 10px;
            font-size: 2.1rem; 
            font-weight: bold;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        @media (min-width: 640px) {
            .submit-button {
                padding: 20px 40px; 
                font-size: 2.8rem; 
            }
        }


        /* 7. ëª¨ë‹¬ ìŠ¤íƒ€ì¼ (ìƒëµ) */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: #fff;
            padding: 50px; 
            border-radius: 20px;
            text-align: center;
            max-width: 90vw; 
            width: 550px; 
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.3s ease;
            display: flex;
            flex-direction: column; 
            align-items: center; 
        }
        .modal-content h2 {
             font-size: 1.2rem; 
             margin-bottom: 25px;
             white-space: nowrap; 
        }
        .modal-content p {
            font-size: 0.7rem;
            line-height: 1.6;
            margin-bottom: 20px;
            text-align: left;
        }
        .start-button { 
            background-color: #48bb78;
            color: white;
            padding: 8px 16px; 
            font-size: 0.9rem; 
            font-weight: bold;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-top: 15px;
        }

        @media (min-width: 640px) {
            .modal-content {
                padding: 70px; 
                width: 700px; 
            }
            .modal-content h2 {
                font-size: 2.2rem; 
            }
            .modal-content p {
                font-size: 1.0rem; 
            }
            .start-button {
                padding: 18px 32px;
                font-size: 1.2rem;
            }
        }
        
        /* 8. ê¸°íƒ€ ìŠ¤íƒ€ì¼ (ìƒëµ) */
        .choice-button:hover:not(:disabled) {
            background-color: #48bb78;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .selected {
            background-color: #38a169 !important;
            color: white !important;
            border-color: #1a472a !important;
            box-shadow: 0 0 8px rgba(56, 161, 105, 0.8);
        }
        .correct {
            background-color: #4299e1 !important;
            color: white !important;
            border-color: #2b6cb0 !important;
        }
        .incorrect {
            background-color: #f56565 !important;
            color: white !important;
            border-color: #c53030 !important;
        }

        /* 9. ëª¨ë°”ì¼(ì‘ì€ í™”ë©´)ì—ì„œ í•œ í™”ë©´ì— ëª¨ë‘ ë³´ì´ë„ë¡ ì••ì¶• ë ˆì´ì•„ì›ƒ */
        @media (max-width: 480px) {
            body {
                padding: 6px;
            }
            .game-container {
                padding: 14px;
                gap: 10px;
                max-height: 100vh;
                height: 100vh;
            }
            .game-container h1 {
                font-size: 1.6rem;
                line-height: 1.1;
            }
            .stat-bar {
                padding: 8px 10px;
                font-size: 0.9rem;
            }
            #flavor-text {
                font-size: 0.9rem;
                margin-bottom: 2px;
            }
            #gameCanvas {
                min-height: 210px;
            }
            .prompt-text {
                font-size: 1.0rem;
                margin-top: 4px;
                margin-bottom: 4px;
            }
            .choice-grid {
                gap: 8px;
                margin-top: 6px;
            }
            .choice-button {
                padding: 9px 4px;
                font-size: 1.1rem;
            }
            .submit-button {
                margin-top: 8px;
                padding: 10px 20px;
                font-size: 1.5rem;
            }
        }

    </style>
    <script src="../js/game-ghost.js"></script>

    <script src="../js/game-ranking-report.js"></script>
</head>
<body>

<div class="game-container">
    <h1 class="text-4xl sm:text-5xl text-center font-extrabold text-green-700 mb-0">ğŸ ê¿ˆí‹€ê¿ˆí‹€ ë„í˜• ì¶”ì ì ğŸ“</h1>
    
    <div class="stat-bar">
        <span>ì ìˆ˜: <span id="scoreDisplay" class="font-bold text-green-900">0</span>ì </span>
        <span>ë¼ìš´ë“œ: <span id="roundDisplay" class="font-bold text-green-900">1</span></span>
        <span>ì‹œê°„: <span id="timeDisplay" class="font-bold text-red-600">10.00</span>ì´ˆ</span>
    </div>

    <div id="flavor-text" class="text-center text-gray-700"></div>

    <canvas id="gameCanvas"></canvas>

    <div class="prompt-text text-center">ì–´ë–¤ ë„í˜•ì´ ê·¸ë ¤ì¡Œë‚˜ìš”? </div>
    <div id="choiceGrid" class="choice-grid">
    </div>
    
    <div class="control-area text-center mt-0"> 
        <button id="submitButton" class="submit-button" disabled>ì œì¶œ (Submit)</button>
    </div>
</div>

<div id="modal" class="modal">
    <div class="modal-content">
        <h2 id="modalTitle" class="font-bold text-green-700">ê²Œì„ ì‹œì‘!</h2>
        <p id="modalMessage" class="text-gray-700 leading-relaxed">
            ë±€ë“¤ì´ í™”ë©´ ë°–ì—ì„œ ë“¤ì–´ì™€ **6ì´ˆ** ë™ì•ˆ ë„í˜•ì„ ê·¸ë¦½ë‹ˆë‹¤.<br>
            ë±€ì´ ì§€ë‚˜ê°€ëŠ” ë„ì¤‘ì—ë„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>
            **10ì´ˆ**ì˜ ì œí•œ ì‹œê°„ ì•ˆì— ê·¸ë ¤ì§„ ë„í˜•ë“¤ì„ ëª¨ë‘ ì„ íƒí•˜ê³  ì œì¶œí•˜ì„¸ìš”.<br><br>
            **1ë¼ìš´ë“œ:** 1ë§ˆë¦¬ | **6ë¼ìš´ë“œë¶€í„°:** 5ë§ˆë¦¬<br>
            **9ë¼ìš´ë“œë¶€í„°:** ì œí•œ ì‹œê°„ 0.5ì´ˆì”© ê°ì†Œ!
        </p>
        <button id="startButton" class="start-button">ê²Œì„ ì‹œì‘</button>
    </div>
</div>

<script type="module">
    // --- ê²Œì„ ìƒíƒœ ë° ìƒìˆ˜ ---

    const SHAPES = [
        { name: "ì‚¼ê°í˜•", sides: 3, icon: "â–³" },
        { name: "ì‚¬ê°í˜•", sides: 4, icon: "â–¡" }, 
        { name: "ì˜¤ê°í˜•", sides: 5, icon: "â¬ " },
        { name: "ìœ¡ê°í˜•", sides: 6, icon: "â¬¡" },
        { name: "ì›", sides: 0, icon: "â—‹" },
        { name: "ë§ˆë¦„ëª¨", sides: 4, icon: "â—‡" }, 
        { name: "ì‚¬ë‹¤ë¦¬ê¼´", sides: 4, icon: "â¢" }
    ];
    
    const CANVAS = document.getElementById('gameCanvas');
    const CTX = CANVAS.getContext('2d');
    const SCORE_DISPLAY = document.getElementById('scoreDisplay');
    const ROUND_DISPLAY = document.getElementById('roundDisplay');
    const TIME_DISPLAY = document.getElementById('timeDisplay');
    const CHOICE_GRID = document.getElementById('choiceGrid');
    const MODAL = document.getElementById('modal');
    const MODAL_TITLE = document.getElementById('modalTitle');
    const MODAL_MESSAGE = document.getElementById('modalMessage');
    const START_BUTTON = document.getElementById('startButton');
    const SUBMIT_BUTTON = document.getElementById('submitButton');
    const FLAVOR_TEXT = document.getElementById('flavor-text');
    const GAME_CONTAINER = document.querySelector('.game-container');

    let game = {
        score: 0,
        round: 1,
        isRunning: false,
        snakes: [],
        correctShapes: [],
        selectedChoices: new Set(),
        currentTotalTime: 10000, 
        drawingDuration: 6000, 
        startTime: 0,
        timerId: null,
        animationFrameId: null,
    };

    const SNAKE_COLORS = [
        '#e53e3e', '#3182ce', '#38a169', '#d69e2e', '#805ad5',
        '#dd6b20', '#00a3c4', '#68d391', '#ecc94b', '#a0aec0'
    ];
    
    // --- ë„í˜• ìƒì„± í•¨ìˆ˜ (ë¡œì§ ìœ ì§€) ---
    function createPolygonPath(sides, size, centerX, centerY) {
        const path = [];
        for (let i = 0; i < sides; i++) {
            const angle = (i * 2 * Math.PI / sides) - (Math.PI / 2);
            path.push({
                x: centerX + size * Math.cos(angle),
                y: centerY + size * Math.sin(angle)
            });
        }
        path.push(path[0]); 
        return path;
    }
    
    function createQuadrilateralPath(size, centerX, centerY) {
        const w = size * (1 + Math.random() * 0.4 - 0.2); 
        const h = size * (1 + Math.random() * 0.4 - 0.2); 

        const rotationAngle = Math.random() * Math.PI / 6; 
        const halfW = w / 2;
        const halfH = h / 2;

        const vertices = [
            { x: -halfW, y: -halfH },
            { x: halfW, y: -halfH },
            { x: halfW, y: halfH },
            { x: -halfW, y: halfH }
        ];

        const path = vertices.map(v => {
            const rotatedX = v.x * Math.cos(rotationAngle) - v.y * Math.sin(rotationAngle);
            const rotatedY = v.x * Math.sin(rotationAngle) + v.y * Math.cos(rotationAngle);
            return {
                x: centerX + rotatedX,
                y: centerY + rotatedY
            };
        });

        path.push(path[0]);
        return path;
    }

    function createCirclePath(size, centerX, centerY) {
        const path = [];
        const segments = 60;
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * 2 * Math.PI;
            path.push({
                x: centerX + size * Math.cos(angle),
                y: centerY + size * Math.sin(angle)
            });
        }
        return path;
    }

    function createRhombusPath(size, centerX, centerY) {
        const hRatio = 1.8; 
        const vRatio = 1.0; 

        const h = size * hRatio * (0.8 + Math.random() * 0.4); 
        const v = size * vRatio * (0.8 + Math.random() * 0.4); 

        const path = [
            { x: centerX, y: centerY - v / 2 },     
            { x: centerX + h / 2, y: centerY },     
            { x: centerX, y: centerY + v / 2 },     
            { x: centerX - h / 2, y: centerY },     
            { x: centerX, y: centerY - v / 2 }      
        ];

        const rotationAngle = Math.PI / 10 + Math.random() * Math.PI / 5; 
        
        const rotatedPath = path.map(p => {
            const dx = p.x - centerX;
            const dy = p.y - centerY;
            const rotatedX = dx * Math.cos(rotationAngle) - dy * Math.sin(rotationAngle);
            const rotatedY = dx * Math.sin(rotationAngle) + dy * Math.cos(rotationAngle);
            return {
                x: centerX + rotatedX,
                y: centerY + rotatedY
            };
        });

        return rotatedPath;
    }

    function createTrapezoidPath(size, centerX, centerY) {
        const h = size; 
        const w1 = size * 1.5; 
        const w2 = size * 0.8; 
        return [
            { x: centerX - w2, y: centerY - h }, 
            { x: centerX + w2, y: centerY - h }, 
            { x: centerX + w1, y: centerY + h }, 
            { x: centerX - w1, y: centerY + h }, 
            { x: centerX - w2, y: centerY - h }  
        ];
    }

    function getShapePath(shapeName, size, centerX, centerY) {
        switch (shapeName) {
            case "ì›":
                return createCirclePath(size, centerX, centerY);
            case "ë§ˆë¦„ëª¨":
                return createRhombusPath(size, centerX, centerY);
            case "ì‚¬ë‹¤ë¦¬ê¼´":
                return createTrapezoidPath(size, centerX, centerY);
            case "ì‚¬ê°í˜•":
                return createQuadrilateralPath(size, centerX, centerY); 
            default:
                const shape = SHAPES.find(s => s.name === shapeName);
                if (!shape) return []; 
                return createPolygonPath(shape.sides, size, centerX, centerY);
        }
    }

    // --- Snake í´ë˜ìŠ¤ ë° ë¡œì§ (ìœ ì§€) ---

    class Snake {
        constructor(shapeName, color, path, totalDistance, segmentDistances) {
            this.shapeName = shapeName;
            this.color = color;
            this.path = path;
            this.totalDistance = totalDistance;
            this.segmentDistances = segmentDistances;
            this.pixelsPerMs = totalDistance / game.drawingDuration;
            this.distanceTraveled = 0;
            this.pathIndex = 0;
            this.trail = [];
            this.maxTrailLength = 190;
            this.isDrawingComplete = false;
        }

        update(deltaTime) {
            if (this.isDrawingComplete) {
                if (this.trail.length > 0) {
                    this.trail.shift();
                }
                return;
            }

            const distanceToTravel = this.pixelsPerMs * deltaTime; 
            this.distanceTraveled += distanceToTravel;

            if (this.distanceTraveled >= this.totalDistance) {
                this.isDrawingComplete = true;
                this.distanceTraveled = this.totalDistance;
            }
            
            let remainingDistance = this.distanceTraveled;
            let pathIndex = 0;

            while (pathIndex < this.segmentDistances.length) {
                const segmentLength = this.segmentDistances[pathIndex];
                if (remainingDistance < segmentLength) {
                    break; 
                }
                remainingDistance -= segmentLength;
                pathIndex++;
            }
            
            this.pathIndex = pathIndex;
            
            if (this.pathIndex < this.segmentDistances.length) {
                const startPoint = this.path[this.pathIndex];
                const endPoint = this.path[this.pathIndex + 1];
                const segmentLength = this.segmentDistances[this.pathIndex];
                
                if (segmentLength === 0) {
                    this.pathIndex++;
                    return;
                }
                
                const t = remainingDistance / segmentLength;

                const newX = startPoint.x + (endPoint.x - startPoint.x) * t;
                const newY = startPoint.y + (endPoint.y - startPoint.y) * t;

                this.trail.push({ x: newX, y: newY });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
            } else {
                if (this.trail.length > 0) {
                    this.trail.shift();
                }
            }
        }

        draw() {
            for (let i = 0; i < this.trail.length; i++) {
                const p = this.trail[i];
                if (p.x < -100 || p.x > CANVAS.width + 100 || p.y < -100 || p.y > CANVAS.height + 100) continue; 
                
                const opacity = (i / this.maxTrailLength) * 0.8 + 0.2; 
                CTX.fillStyle = this.color;
                CTX.globalAlpha = opacity;
                CTX.beginPath();
                const radius = (i / this.maxTrailLength) * 3 + 2; 
                CTX.arc(p.x, p.y, radius, 0, Math.PI * 2);
                CTX.fill();
            }
            CTX.globalAlpha = 1.0; 

            if (this.trail.length > 0) {
                const head = this.trail[this.trail.length - 1];
                if (head.x >= -50 && head.x <= CANVAS.width + 50 && head.y >= -50 && head.y <= CANVAS.height + 50) {
                    CTX.fillStyle = this.color;
                    CTX.beginPath();
                    CTX.arc(head.x, head.y, 6, 0, Math.PI * 2); 
                    CTX.fill();
                }
            }
        }
    }


    // --- ê²Œì„ ì´ˆê¸°í™” ë° ì œì–´ í•¨ìˆ˜ ---
    
    // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì • ë¡œì§ (ê°„ì†Œí™”)
    function initCanvas() {
        // ìº”ë²„ìŠ¤ì˜ ë„ˆë¹„ë§Œ ì„¤ì • (ë†’ì´ëŠ” CSS flex-growê°€ ì²˜ë¦¬)
        if (GAME_CONTAINER) {
            CANVAS.width = GAME_CONTAINER.clientWidth;
            // ìº”ë²„ìŠ¤ ë†’ì´ëŠ” flex-growì— ì˜í•´ ì´ë¯¸ ì„¤ì •ë˜ì§€ë§Œ, 
            // ë±€ì˜ ê²½ë¡œ ê³„ì‚°ì„ ìœ„í•´ í”½ì…€ ê°’ì„ ì„¤ì •í•©ë‹ˆë‹¤.
            // ìº”ë²„ìŠ¤ ë†’ì´ë¥¼ ë‹¤ì‹œ ê³„ì‚°í•˜ì§€ ì•Šê³  í˜„ì¬ í´ë¼ì´ì–¸íŠ¸ ë†’ì´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
            CANVAS.height = CANVAS.clientHeight;
        }
    }


    function getNumSnakes(round) {
        if (round >= 6) return 5;
        if (round >= 4) return 3;
        if (round >= 2) return 2;
        return 1;
    }

    function setupNewRound() {
        try {
            // 1. ìƒíƒœ ì´ˆê¸°í™”
            game.snakes = [];
            game.correctShapes = [];
            game.selectedChoices.clear();
            FLAVOR_TEXT.textContent = '';
            SUBMIT_BUTTON.disabled = true;

            // 2. ì‹œê°„ ì œí•œ ì—…ë°ì´íŠ¸
            if (game.round >= 9) {
                game.currentTotalTime = Math.max(7000, game.currentTotalTime - 500); 
            } else {
                game.currentTotalTime = 10000;
            }

            // 3. ë„í˜• ê²°ì • ë° ë±€ ìƒì„±
            const numSnakes = getNumSnakes(game.round);
            const availableShapes = [...SHAPES];
            const chosenShapes = [];

            for (let i = 0; i < numSnakes; i++) {
                const randomIndex = Math.floor(Math.random() * availableShapes.length);
                chosenShapes.push(availableShapes[randomIndex]);
                availableShapes.splice(randomIndex, 1);
            }
            game.correctShapes = chosenShapes.map(s => s.name).sort();
            
            // ë±€ì´ ê·¸ë¦¬ëŠ” ë„í˜•ì˜ í¬ê¸° ì¡°ì •
            const minDim = Math.min(CANVAS.width, CANVAS.height);
            const maxShapeSize = minDim * 0.35; 
            const minShapeSize = minDim * 0.25;
            const padding = minDim * 0.15; 

            for (let i = 0; i < numSnakes; i++) {
                const shape = chosenShapes[i];
                const color = SNAKE_COLORS[i % SNAKE_COLORS.length];
                
                const centerX = padding + (CANVAS.width - 2 * padding) * Math.random();
                const centerY = padding + (CANVAS.height - 2 * padding) * Math.random();
                
                const size = minShapeSize + Math.random() * (maxShapeSize - minShapeSize); 
                
                const shapePath = getShapePath(shape.name, size, centerX, centerY);
                
                // ë±€ì´ ìº”ë²„ìŠ¤ ë°–ì—ì„œ ë“¤ì–´ì˜¤ê³  ë‚˜ê°€ëŠ” ì´ˆê¸°/ì¢…ë£Œ ì§€ì  ì¡°ì •
                const entryPoint = { 
                    x: Math.random() < 0.5 ? -CANVAS.width * 0.3 : CANVAS.width * 1.3,
                    y: CANVAS.height * Math.random() 
                }; 
                const exitPoint = { 
                    x: Math.random() < 0.5 ? -CANVAS.width * 0.3 : CANVAS.width * 1.3,
                    y: CANVAS.height * Math.random() 
                }; 

                if (Math.abs(entryPoint.x - exitPoint.x) < CANVAS.width * 0.5 && 
                    Math.abs(entryPoint.y - exitPoint.y) < CANVAS.height * 0.5) {
                    exitPoint.x = (entryPoint.x > CANVAS.width / 2) ? -CANVAS.width * 0.3 : CANVAS.width * 1.3;
                    exitPoint.y = (entryPoint.y > CANVAS.height / 2) ? CANVAS.height * 0.2 : CANVAS.height * 0.8;
                }
                
                const fullPath = [entryPoint, ...shapePath, exitPoint];
                
                let totalPathDistance = 0;
                let segmentDistances = [];
                for(let j=0; j < fullPath.length - 1; j++) {
                    const p1 = fullPath[j];
                    const p2 = fullPath[j+1];
                    const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    totalPathDistance += dist;
                    segmentDistances.push(dist);
                }
                
                if (totalPathDistance === 0) continue; 

                game.snakes.push(new Snake(shape.name, color, fullPath, totalPathDistance, segmentDistances));
            }

            // 5. ì„ íƒì§€ ë²„íŠ¼ ìƒì„±
            const allPossibleShapes = [...SHAPES];
            const choiceNames = new Set(game.correctShapes);
            while (choiceNames.size < 6) {
                const randomShape = allPossibleShapes[Math.floor(Math.random() * allPossibleShapes.length)];
                choiceNames.add(randomShape.name);
            }
            
            const choices = Array.from(choiceNames).map(name => SHAPES.find(s => s.name === name));
            choices.sort(() => Math.random() - 0.5);

            CHOICE_GRID.innerHTML = '';
            choices.forEach(shape => {
                const button = document.createElement('button');
                button.className = 'choice-button';
                button.id = `choice-${shape.name}`;
                button.innerHTML = `${shape.icon} ${shape.name}`;
                button.disabled = true; 
                button.onclick = () => handleChoice(shape.name, button);
                CHOICE_GRID.appendChild(button);
            });
            
            // 6. UI ì—…ë°ì´íŠ¸
            updateUI();
            
            // 7. ê²Œì„ ì‹œì‘
            game.isRunning = true;
            game.startTime = performance.now();
            
            lastTime = game.startTime; 
            
            gameLoop(performance.now());
            startTimer();

        } catch (error) {
            console.error(error);
            FLAVOR_TEXT.textContent = 'âŒ ê²Œì„ ì„¤ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ!';
            game.isRunning = false;
        }
    }

    function handleChoice(shapeName, button) {
        if (!game.isRunning || performance.now() - game.startTime > game.currentTotalTime) return;

        if (game.selectedChoices.has(shapeName)) {
            game.selectedChoices.delete(shapeName);
            button.classList.remove('selected');
        } else {
            if (game.selectedChoices.size < game.correctShapes.length) { 
                game.selectedChoices.add(shapeName);
                button.classList.add('selected');
            } else {
                button.classList.add('animate-pulse');
                setTimeout(() => button.classList.remove('animate-pulse'), 500);
            }
        }
    }

    function updateUI() {
        SCORE_DISPLAY.textContent = game.score;
        ROUND_DISPLAY.textContent = game.round;
        TIME_DISPLAY.textContent = (game.currentTotalTime / 1000).toFixed(2);
    }

    let lastTime = 0;
    function gameLoop(timestamp) {
        if (!game.isRunning) return;

        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);

        const elapsed = performance.now() - game.startTime;

        if (elapsed <= game.drawingDuration || game.snakes.some(s => s.trail.length > 0)) {
             game.snakes.forEach(snake => snake.update(deltaTime));
        }

        game.snakes.forEach(snake => snake.draw());

        game.animationFrameId = requestAnimationFrame(gameLoop);
    }

    function startTimer() {
        const totalTime = game.currentTotalTime;
        
        const choiceButtons = document.querySelectorAll('.choice-button');
        SUBMIT_BUTTON.onclick = () => endRound(true);

        choiceButtons.forEach(btn => btn.disabled = false);
        SUBMIT_BUTTON.disabled = false;
        
        game.timerId = setInterval(() => {
            const elapsed = performance.now() - game.startTime;
            const remaining = Math.max(0, totalTime - elapsed);
            
            TIME_DISPLAY.textContent = (remaining / 1000).toFixed(2);
            
            if (remaining <= 0) {
                clearInterval(game.timerId);
                cancelAnimationFrame(game.animationFrameId);
                endRound(false); // ì‹œê°„ ì´ˆê³¼
            }
        }, 50);
    }

    function endRound(isSubmitted) {
        if (!game.isRunning) return;
        game.isRunning = false;
        clearInterval(game.timerId);
        cancelAnimationFrame(game.animationFrameId);

        // 1. ë²„íŠ¼ ë¹„í™œì„±í™” ë° ê²°ê³¼ í‘œì‹œ
        const buttons = document.querySelectorAll('.choice-button');
        buttons.forEach(btn => {
            btn.disabled = true;
            const name = btn.id.replace('choice-', '');
            const isCorrectAnswer = game.correctShapes.includes(name);
            const isPlayerSelected = game.selectedChoices.has(name);
            
            btn.classList.remove('selected');

            if (isCorrectAnswer) {
                btn.classList.add('correct');
            } else if (isPlayerSelected) {
                btn.classList.add('incorrect');
            }
        });
        SUBMIT_BUTTON.disabled = true;
        
        // 2. ê²°ê³¼ ê³„ì‚° ë° ì²˜ë¦¬
        const correctCount = game.correctShapes.length;
        const correctSelections = Array.from(game.selectedChoices).filter(choice => game.correctShapes.includes(choice));
        const isPerfect = correctSelections.length === correctCount && game.selectedChoices.size === correctCount;
        
        let message = '';
        let title = '';

        if (isPerfect) {
            // [ì˜µì…˜] ê²Œì„ìš© ê³ ìŠ¤íŠ¸: ì •ë‹µ ë§ì·„ì„ ë•Œ ê¸°ì¨ í‘œí˜„
            if (window.gameGhostUI && typeof window.gameGhostUI.react === "function") {
                try { window.gameGhostUI.react("correct"); } catch(e) {}
            }
            const points = 20; 
            game.score += points;

            title = "ğŸ‰ ì™„ë²½ ì„±ê³µ! 20ì  íšë“! ğŸ‰";
            message = `ëª¨ë“  ë„í˜• ${correctCount}ê°œë¥¼ ì •í™•íˆ ë§ì·„ìŠµë‹ˆë‹¤.<br>ë‹¤ìŒ ë¼ìš´ë“œë¡œ ì´ë™í•©ë‹ˆë‹¤.`;
            
            // ì„±ê³µ: ë‹¤ìŒ ë¼ìš´ë“œ ì„¤ì •
            START_BUTTON.textContent = "ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘";
            START_BUTTON.onclick = () => {
                MODAL.style.display = 'none';
                game.round++;
                initCanvas(); 
                setupNewRound();
            };

        } else {
            // [ì˜µì…˜] ê²Œì„ìš© ê³ ìŠ¤íŠ¸: ê²Œì„ ì˜¤ë²„/ì‹¤íŒ¨ ë°˜ì‘
            if (window.gameGhostUI && typeof window.gameGhostUI.react === "function") {
                try { window.gameGhostUI.react("gameover"); } catch(e) {}
            }
            // ì‹¤íŒ¨: ì ìˆ˜ ë° ë¼ìš´ë“œ ì´ˆê¸°í™”
            title = "âŒ ì‹¤íŒ¨! ê²Œì„ ì˜¤ë²„ âŒ";
            message = isSubmitted 
                ? `ì •ë‹µì€ ${game.correctShapes.join(', ')} ì´ì—ˆìŠµë‹ˆë‹¤. ìµœì¢… ì ìˆ˜: ${game.score}ì .`
                : `ì‹œê°„ ì´ˆê³¼! ì •ë‹µì€ ${game.correctShapes.join(', ')} ì´ì—ˆìŠµë‹ˆë‹¤. ìµœì¢… ì ìˆ˜: ${game.score}ì .`;
            
            const finalScore = game.score || 0;

            // âœ… ê¿ˆí‹€ì´ë„í˜•ì¶”ì ì ë­í‚¹ ì „ì†¡ (ê²Œì„ ì¢…ë£Œ ì‹œ ìµœì¢… ì ìˆ˜ ê¸°ì¤€, ë¶€ëª¨ ì°½ìœ¼ë¡œ ë©”ì‹œì§€ ì „ì†¡)
            try {
              if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                  type: "GAME_SCORE",
                  gameName: "ê¿ˆí‹€ì´ë„í˜•ì¶”ì ì",
                  score: finalScore
                }, "*");
              }
            } catch(e) {}

            game.score = 0; 
            game.round = 1; 

            // ì‹¤íŒ¨: ë‹¤ì‹œ ì‹œì‘ ì„¤ì •
            START_BUTTON.textContent = "ë‹¤ì‹œ ì‹œì‘";
            START_BUTTON.onclick = initialStartGame; 
        }

        updateUI();

        // 3. ëª¨ë‹¬ í‘œì‹œ
        MODAL_TITLE.textContent = title;
        MODAL_MESSAGE.innerHTML = message;
        MODAL.style.display = 'flex';
    }

    // --- ì´ˆê¸° ì‹œì‘ í•¨ìˆ˜ ---
    const initialStartGame = () => {
        // [ì˜µì…˜] ê²Œì„ìš© ê³ ìŠ¤íŠ¸: ê²Œì„ ì‹œì‘ ë°˜ì‘ (game-ghost.js ì‚­ì œ ì‹œ ì´ ë¸”ëŸ­ë„ í•¨ê»˜ ì‚­ì œ ê°€ëŠ¥)
        if (window.gameGhostUI && typeof window.gameGhostUI.react === "function") {
            try { window.gameGhostUI.react("start"); } catch(e) {}
        }
        MODAL.style.display = 'none';
        game.score = 0;
        game.round = 1;
        initCanvas();
        setupNewRound();
    };

    // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---

    document.addEventListener('keydown', (e) => {
        if (game.isRunning) {
            if (e.key === ' ' || e.key === 'Enter') {
                e.preventDefault();
                endRound(true);
            }
        }
    });

    window.addEventListener('resize', initCanvas);
    
    window.onload = () => {
        // ìš”ì†Œë“¤ì´ ë¡œë“œëœ í›„ ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì •í™•íˆ ê³„ì‚°í•˜ê¸° ìœ„í•´ setTimeout ì‚¬ìš©
        setTimeout(() => {
            // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì„¤ì •í•˜ê¸° ìœ„í•´ initCanvas í˜¸ì¶œ
            initCanvas(); 
            MODAL.style.display = 'flex';
            START_BUTTON.onclick = initialStartGame;
        }, 100); 
    };

</script>

</body>
</html>